## 10. 파티션

파티션이란 MySQL 서버의 입장에서는 데이터를 별도의 테이블로 분리해서 저장하지만 사용자 입장에서는 여전히 하나의 테이블로 읽기와 쓰기를 할 수 있게 해주는 솔루션이다.<br>
파티션은 하나의 서버에서 테이블을 분산하는 것이다.<br>
해시와 리스트, 키와 레인지로 4가지 파티션 방법을 제공하고 있으며, 서브 파티셔닝 기능까지 사용할 수 있다.<br>

## 10.1 개요

> 파티션이 SQL 문장의 수행에 어떻게 영향을 미치는지, 그리고 파티션으로 기대할 수 있는 장점이 무엇이 있는지 살펴본다.

### 10.1.1 파티션을 사용하는 이유

하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나, 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등이 파티션이 필요한 대표적인 예이다.

**단일 INSERT 와 단일 또는 범위 SELECT의 빠른 처리**

파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 만들어준다.

<img src="/partition/img/10-1.png" width="500px;" />

```
테이블의 데이터가 10GB이고 인덱스가 3GB라고 가정해보자. 하지만 대부분의 테이블은 13GB 전체를 항상 사용하는 것이 아니라 그중에서 활발하게 사용하는 부분을 주로 다시 사용한다.
즉, 회원이 100만 명이라 하더라도 그중에서 활발하게 사용하는 회원은 20~30% 수준이라는 것이다.
활발하게 사용되는 데이터를 워킹 셋이라고 표현한다.
```

**데이터의 물리적인 저장소를 분리**

데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 그만큼 백업이나 관리 작업이 어려워진다.<br>
이러한 문제는 파티션을 통해 크기를 조절하거나 각 파티션별 파일들이 저장될 위치나 디스크를 구분해서 지정해서 해결하는 것도 가능하다.<br>

**이력 데이터의 효율적인 관리**

로그 테이블을 파티션 테이블로 관리한다면 불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 간단하고 빠르게 해결할 수 있다.

<img src="/partition/img/10-2.png" width="500px;" />

대량의 데이터가 저장된 로그 테이블을 기간 단위로 삭제한다면 MySQL 서버에 전체적으로 미치는 부하뿐 아니라 로그 테이블 자체의 동시성에도 영향을 미칠 수가 있다.<br>
하지만 파티션을 이용하면 이러한 문제를 대폭 줄일 수 있다.<br>

### 10.1.2 MySQL 파티션의 내부 처리

파티션이 적용된 테이블에서 레코드의 INSERT 와 UPDATE, 그리고 SELECT가 어떻게 처리되는지 확인해보기 위해 다음과 같은 간단한 테이블을 가정해 보자.

```sql
CREATE TABLE tb_article {
	article_id INT NOT NULL,
	reg_date DATETIME NOT NULL,
	...,
	PRIMARY KEY(article_id)
}
PARTITION BY RANGE ( YEAR(reg_date) ) (
	PARTITION p2009 VALUES LESS THAN (2010),
	PARTITION p2010 VALUES LESS THAN (2011),
	PARTITION p2011 VALUES LESS THAN (2012),
	PARTITION p9999 VALUES LESS THAN MAXVALUE
);
```

게시물의 등록 일자(reg_date)에서 연도 부분은 파티션 키로서 해당 레코드가 어느 파티션에 저장될지를 결정하는 중요한 역할을 담당한다.

**파티션 테이블의 레코드 INSERT**

INSERT 쿼리가 실행되면 MySQL 서버는 INSERT 되는 칼럼의 값 중에서 파티션 키인 reg_date 칼럼의 값을 이용해 파티션 표현식을 평가하고, 그 결과를 이용해 레코드가 저장될 적절한 파티션을 결정한다.<br>
새로 INSERT 되는 레코드를 위한 파티션이 결정되면 나머지 과정은 파티션되지 않은 일반 테이블과 마찬가지로 처리된다.<br>

<img src="/partition/img/10-3.png" width="500px;" />

**파티션 테이블의 UPDATE**

UPDATE 쿼리를 실행하려면 변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾아야 한다.<br>
이 때 UPDATE  쿼리의 WHERE 조건에 파티션 키 칼럼이 조건으로 존재한다면 그 값을 이용해 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색할 수 있다.<br>
하지만 WHERE 조건에 파티션 키 칼럼의 조건이 명시되지 않았다면 MySQL 서버는 변경 대상 레코드를 찾기 위해 테이블의 모든 파티션을 검색해야 한다.<br>
레코드의 칼럼을 변경하는 작업 절차는 UPDATE 쿼리가 어떤 칼럼의 값을 변경하는지에 따라 큰 차이가 생긴다.<br>

- 파티션 키 이외의 칼럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 칼럼 값만 변경한다.
- 파티션 키 칼럼이 변경될 때는 [그림 10-4]의 1번 단계와 같이 기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제한다.
  그리고 변경되는 파티션 키 칼럼의 표현식을 평가하고, 그 결과를 이용해 레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 저장한다.

<img src="/partition/img/10-4.png" width="500px;" />

**파티션 테이블의 검색**

SQL이 수행되기 위해 파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건은 다음과 같다.

- WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
- WHERE 절의 조건이 인덱스를 효율적으로 사용(인덱스 레인지 스캔)할 수 있는가?

위의 두 가지 주요 선택사항의 각 조합이 어떻게 실행되는지 살펴보자.

**파티션 선택 가능 + 인덱스 효율적 사용 가능**

두 선택사항이 모두 사용 가능할 때 쿼리가 가장 효율적으로 처리 될 수 있다.<br>
파티션의 개수에 관계없이 검색을 위해 꼭 필요한 파티션의 인덱스만 레인지 스캔한다.<br>

**파티션 선택 불가 + 인덱스 효율적 사용 가능**

모든 파티션을 대상으로 검색해야 한다.<br>
각 파티션에 대해서는 인덱스 레인지 스캔을 사용할 수 있기 때문에 최종적으로 테이블에 존재하는 모든 파티션의 개수만큼 인덱스 레인지 스캔을 수행해서 검색하게 된다.<br>
이 작업은 파티션 개수만큼의 테이블에 대해 인덱스 레인지 스캔을 한 다음 결과를 병합해서 가져오는 것과 같다.<br>

**파티션 선택 가능 + 인덱스 효율적 사용 불가**

검색하려는 레코드가 저장된 파티션을 선별할 수 있기 때문에 파티션 개수에 관계없이 검색을 위해 필요한 파티션만 읽으면 된다.<br>
하지만 인덱스는 이용할 수 없기 때문에 대상 파티션에 대해 풀 테이블 스캔을 한다.<br>

**파이션 선택 불가 + 인덱스 효율적 사용 불가**

모든 파티션을 검색해야 하고 각 파티션을 검색하는 작업 자체도 풀 테이블 스캔을 수행해야 한다.<br>
마지막 세 번째와 네 번째 방식은 가능하다면 피하는 것이 좋다.<br>
두 번째 조합 또한 하나의 테이블에 파티션의 개수가 많을 때는 MySQL 서버의 부하도 높아지고 처리 시간도 많이 느려지므로 주의하자.<br>

**파티션 테이블의 인덱스 스캔과 정렬**

MySQL의 파티션 테이블에서 인덱스는 전부 로컬 인덱스에 해당한다.<br>
모든 인덱스는 파티션 단위로 생성되며, 파티션에 관계없이 테이블 전체 단위로 글로벌하게 하나의 통합된 인덱스는 지원하지 않는다는 것을 의미한다.<br>

<img src="/partition/img/10-5.png" width="500px;" />

실제 MySQL 서버는 여러 파티션에 대해 인덱스 스캔을 수행할 때, 각 파티션으로부터 조건에 일치하는 레코드를 정렬된 순서대로 읽으면서 우선순위 큐(Priority Queue)에 임시로 저장한다.<br>
그리고 우선 순위 큐에서 다시 필요한 순서(인덱스의 정렬 순서)대로 데이터를 가져가는 것이다.<br>
결론적으로 파티션 테이블에서 인덱스 스캔을 통해 레코드를 읽을 때 MySQL 서버가 별도의 정렬 작업을 수행하지 않는다.<br>
하지만 일반 테이블의 인덱스 스캔처럼 결과를 바로 변환하는 것이 아니라 내부적으로 큐 처리가 한번 필요한 것이다.<br>

[그림 10-5]에서 "머지 & 소트(Merge & Sort)"라고 표시한 부분이 바로 우선 순위 큐 처리 작업을 의미한다.

**파티션 프루닝(Partition pruning)**

[그림 10-5]에서 보는 것처럼 옵티마이저에 의해 3개의 파티션 가운데 2개만 읽어도 된다고 판단되면 불필요한 파티션에는 전혀 접근하지 않는다.

이렇게 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 파티션 프루닝(Partition pruning)이라 한다.

## 10.2 주의사항

### 10.2.1 파티션의 제한 사항

- 숫자 값(INTEGER 타입 칼럼 또는 INTEGER 타입을 반환하는 함수 및 표현식)에 의해서만 파티션이 가능하다. (MySQL 5.5 부터는 문자열이나 날짜 타임 모두 사용할 수 있게 됨)
- 키 파티션은 해시 함수를 MySQL이 직접 선택하기 때문에 칼럼 타입의 제한은 없다.
- 최대 1024개의 파티션을 가질 수 있다.(서브 파티션까지 포함)
- 스토어드 루틴이나 UDF 그리고 사용자 변수 등을 파티션 함수나 식에 사용할 수 없다.
- 파티션 생성 이후 MySQL 서버의 sql_mode 파라미터 변경은 추천하지 않는다.
- 파티션 테이블에서 외래키는 사용 불가하다.
- 파티션 테이블은 전문 검색 인덱스가 생성 불가하다.
- 공간 확장 기능에서 제공되는 칼럼 타입(POINT, GEOMETRY, ...)은 파티션 테이블에서 사용 불가하다.
- 임시 테이블(Temporary table)은 파티션 기능 사용 불가하다.
- 파티션 키의 표현식은 일반적으로 칼럼 그 자체 또는 MySQL 내장 함수를 사용할 수 있는데, 여기서 MySQL 내장 함수를 모두 사용할 수 있는 것이 아니라 일부만 사용할 수 있다.
  하지만 이 함수 중에서도 정상적으로 파티션 프루닝을 지원하는 함수는 YEAR(), TO_DAYS(), 그리고 TO_SECONDS() 밖에 없으므로 제대로 파티션의 기능을 이용하려고 한다면 INTEGER 타입의 칼럼 그 자체 또는 3가지 내장 함수를 사용한 표현식을 파티션 키로 사용할 것을 권장한다.

MySQL의 파티션에서 인덱스는 로컬이나 글로벌의 의미가 없이 모두 로컬 인덱스이다.<br>
즉, 파티션 단위로 인덱스를 변경하거나 추가할 수 없다.<br>
또한 하나의 테이블에 소속된 파티션은 다른 종류의 스토리지 엔진으로 구성하는 것을 추천하지 않는다.<br>
위의 제약사항을 고려해 보면 MySQL 5.1에서는 INTEGER 칼럼과 DATE(또는 DATETIME) 타입의 칼럼으로 파티션된 테이블만 제대로 된 기능(파티션 생성 및 파티션 프루닝)을 활용할 수 있을 것으로 보인다.<br>

### 10.2.2 파티션 사용 시 주의사항

**파티션과 유니크 키(프라이머리 키 포함)**

종류에 관계없이 테이블에 유니크 인덱스(프라이머리 키 포함)가 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 칼럼을 포함해야 한다.<br>
파티션 키로 사용할 수 있는 예제를 보자.<br>

```sql
CREATE TABLE tb_partition (
	fd1 INT NOT NULL, fd2 INT NOT NULL, fd3 INT NOT NULL,
	UNIQUE KEY (fd1, fd2, fd3)
) PARTITION BY HASH (fd1)
PARTITION 4;

CREATE TABLE tb_partition (
	fd1 INT NOT NULL, fd2 INT NOT NULL, fd3 INT NOT NULL,
	UNIQUE KEY (fd1, fd2)
) PARTITION BY HASH (fd1 + fd2)
PARTITION 4;

CREATE TABLE tb_partition (
	fd1 INT NOT NULL, fd2 INT NOT NULL, fd3 INT NOT NULL,
	UNIQUE KEY (fd1, fd2, fd3)
	UNIQUE KEY (fd3)
) PARTITION BY HASH (fd3)
PARTITION 4;
```

위의 예제 3개는 각 유니크 키를 구성하는 칼럼의 값이 결정되면 해당 레코드가 어느 파티션에 저장돼 있는지 계산할 수 있다는 사실을 알 수 있다.<br>
모두 해시 파티션으로 예를 들었지만 이는 파티션 방식에 관계없이 모든 파티션 테이블에서 프라이머리 키나 유니크 키를 생성하기 위해 지켜야 할 요건이다.<br>

**파티션과 open_files_limit 파라미터**

MySQL에서는 일반적으로 테이블을 파일 단위로 관리하기 때문에 MySQL 서버에서 동시에 오픈된 파일의 개수가 상당히 많아 질 수 있다.<br>
이를 제한하기 위해 open-files-limit 시스템 변수에 동시에 오픈할 수 있는 적절한 파일의 개수를 설정할 수 있다.<br>
파티션 되지 않은 일반 테이블은 테이블 1개당 오픈된 파일의 개수가 2~3개 수준이지만 파티션 테이블에서는 (파티션의 개수 * 2~3)개가 된다.<br>
파티션을 많이 사용하는 경우에는 open-files-limit를 적절히 높은 값으로 다시 설정해 줄 필요가 있다.<br>

**파티션 테이블과 잠금**

파티션 테이블에 쿼리가 실행되면 MySQL 서버는 테이블의 파티션 개수에 관계없이 모든 파티션을 열고 잠금을 걸게 된다.<br>
이는 테이블의 파티션 개수가 많아지면 많아질수록 더 느려지게 되므로 적정 수준의 파티션이 있는 테이블에서는 오히려 더 느려지는 현상이 발생하는 것이다.<br>
파티션이 많이 포함된 테이블에 한 번에 많은 레코드를 INSERT 하거나 UPDATE 한다면 LOCK TABLS 명령으로 테이블을 잠그고 INSERT 나 UPDATE를 수행하면 조금은 더 빠르게 처리할 수 있다.<br>

## 10.3 MySQL 파티션의 종류

4가지 기본 파티셔닝 기법을 제공하고 있다.

- 레인지 파티션
- 리스트 파티션
- 해시 파티션
- 키 파티션

### 10.3.1 레인지 파티션

파티션 키의 연속된 범위로 파티션을 정의하는 방법으로, 가장 일반적으로 사용되는 파티션 방법중 한가지 이다.

**레인지 파티션의 용도**

다음과 같은 성격을 지닌 테이블에서는 레인지 파티션을 사용하는 것이 좋다.<br>
마지막 항목은 모든 파티션에 일반적으로 적용되는 내용이지만 레인지나 리스트 파티션에 더 필요한 요건이다.<br>

- 날짜를 기반으로 데이터가 누적되고 년도나 월 또는 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 실행될 때

**레인지 파티션 테이블 생성**

```sql
CREATE TABLE employees (
	int INT NOT NULL,
	first_name VARCHAR(30),
	last_name VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	...
) ENGINE=INNODB
PARTITION BY RANGE ( YEAR(hired) ) (
	PARTITION p0 VALUES LESS THAN (1991) ENGINE=INNODB,
	PARTITION p1 VALUES LESS THAN (1996) ENGINE=INNODB,
	PARTITION p2 VALUES LESS THAN (2001) ENGINE=INNODB,
	PARTITION p3 VALUES LESS THAN MAXVALUE ENGINE=INNODB
);
```

- PARTITION BY RANGE 키워드로 레인지 파티션을 정의
- PARTITION BY RANGE 뒤에 칼럼 또는 내장 함수를 이용해 파티션 키를 명시한다.
- VALUES LESS THAN 으로 명시된 값보다 작은 값만 해당 파티션에 저장되도록 설정한다.
  단, LESS THAN  절에 명시된 값은 그 파티션에 포함되지 않는다.
- VALUE LESS THAN MAXVALUE 로 명시되지 않은 레코드를 저장할 파티션을 지정한다.
  이 예제에서 2001년 부터 9999년 사이에 입사한 사원의 정보는 p3 파티션에 저장될 것이다.
  VALUE LESS THAN MAXVALUE 파티션은 선택사항이므로 지정하지 않아도 된다.
- VALUE LESS THAN MAXVALUE 가 정의되지 않으면 hired 칼럼의 값이 '2011-02-30'인 레코드가 INSERT 될 때 에러가 발생하면서 "Table has no partition for value 2011" 이라는 메시지가 표시될 것이다.
- 테이블과 각 파티션은 같은 스토리지 엔진으로 정의한다.
  각 파티션에 ENGINE 을 명시하지 않으면 테이블의 스토리지 엔진이 자동으로 적용된다.
  이 예제에서는 테이블의 스토리지 엔진이 InnoDB이므로 자동으로 모든 파티션의 스토리지 엔진은 InnoDB를 사용할 것이다.

파티션된 테이블에 레코드가 INSERT 될 때는 다음과 같이 입사일자에 따라 각각 다른 파티션에 저장된다.

- p0 파티션 : 입사 일자가 1990년 이하인 레코드
- p1 파티션 : 입사 일자가 1991년 부터 1996년 이하인 레코드
- p2 파티션 : 입사 일자가 1996년 부터 2000년 이하인 레코드
- p3 파티션 : 입사 일자가 2001년 이후인 레코드

**레인지 파티션의 분리와 병합**

**단순 파티션의 추가**

다음은 employees 테이블의 입사 일자가 2001년부터 2010년 이하인 레코드를 저장하기 위한 새로운 파티션 p4를 추가하는 ALTER TABLE 명령이다.

```sql
ALTER TABLE employees ADD PARTITION (PARTITION p4 VALUES LESS THAN (2011));
```

테이블에 MAXVALUE 파티션이 이미 정의돼 있을 때는 테이블에 새로운 파티션을 추가할 수 없다.<br>
이때는 MAXVALUE 파티션을 분리하는 방법으로 새로운 파티션을 끼워 넣어야 한다.<br>

**단순 파티션 삭제**

```sql
ALTER TABLE employees DROP PARTITION p0;
```

**기존 파티션의 분리**

하나의 파티션을 두 개 이상의 파티션으로 분리하고자 할 때는 REORGANIZE 명령을 사용하면 된다.<br>
다음 예제는 MAXVALUE 파티션인 p3을 두 개 파티션으로 나누는 명령이다.<br>
기존 MAXVALUE 파티션에 저장돼 있던 데이터는 파티션 키에 의해 데이터까지 p3과 p4 파티션으로 적절히 재배치 되어 저장된다.<br>

```sql
ALTER TABLE employees
	REORGANIZE PARTITION p3 INTO (
	PARTITION p3 VALUES LESS THAN (2012),
	PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

MAXVALUE 파티션뿐 아니라 다른 파티션들도 REORGANIZE PARTITION 명령을 이용해 분리할 수 있다.

**기존 파티션의 병합**

여러 파티션을 하나의 파티션으로 병합하는 작업도 REORGANIZE PARTITION 명령으로 처리할 수 있다.<br>
아래는 employees 테이블의 p2 파티션과 p3 파티션을 p23 파티션으로 병합하는 예제이다.<br>

```sql
ALTER TABLE employees
	REORGANIZE PARTITION p2, p3 INTO (
	PARTITION p23 VALUES LESS THAN (2012)
)
```

**레인지 파티션 주의사항**

레인지 파티션에서 NULL는 어떤 값보다 작은 값으로 간주된다.<br>
날짜 칼럼의 값으로 파티션을 만들 경우, 다음과 같은 파티션 키를 사용하는 파티셔닝을 피하는 것이 좋다.<br>

- UNIX_TIMESTAMP()를 이용한 변환 식을 파티션 키로 사용
- 날짜를 문자열로 포맷팅한 형태('2011-12-30')의 파티션 키
- YEAR(), TO_DAYS() 함수 이외의 함수가 사용된 파티션 키

날짜 칼럼에 대해 레인지 파티션을 적용할 경우 파티션 키로 다음 2개의 함수 중 하나를 사용하길 권장한다.

- YEAR(date_column)
- TO_DAYS(date_column)

MySQL 서버 내부적으로 파티션 프루닝 처리가 최적화돼 있어 성능상의 문제가 발생하지 않는다.

### 10.3.2 리스트 파티션

레인지 파티션과 많은 부분에서 흡사하게 동작한다.<br>
둘의 가장 큰 차이는 레인지 파티션은 파티션 키의 연속된 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키값 하나하나를 리스트로 나열해야 한다는 점이다.<br>
또한, 리스트 파티션에서는 레인지 파티션과 같이 MAXVALUE 파티션을 정의할 수 없다.<br>

**리스트 파티션의 용도**

테이블이 다음과 같은 특성을 지닐 때는 리스트 파티션을 사용하는 것이 좋다.<br>
마지막 항목은 모든 파티션에 공통적인 사항이지만 레인지나 리스트 파티션에 더 필요한 사항이다.<br>

- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고, 검색 조건에 파티션 키가 자주 사용될 때

```sql
CREATE TABLE product(
	id INT NOT NULL,
	name VARCHAR(30),
	category_id INT NOT NULL,
	...
)
PARTITION BY LIST (category_id) (
	PARTITION pappliance VALUES IN (3),
	PARTITION pcomputer VALUES IN (1,9),
	PARTITION psports VALUES IN (2,6,7),
	PARTITION petc VALUES IN (4,5,8,NULL),		
);
```

위 예제는 리스트 파티션 테이블을 생성하는 명령이다.

- PARTITION BY LIST 키워드로 생성할 파티션이 리스트 파티션이라는 것을 명시한다.
- PARTITION BY LIST  키워드 뒤에 파티션 키를 정의한다.
  이 예제에서는 INT(문자열도 가능) 타입의 category_id 칼럼 값을 그대로 파티션 키로 사용하고 있다.
- VALUES IN (...) 을 사용해 각 파티션별로 저장할 파티션 키 값의 목록을 나열한다.
- 위 예제의 마지막 파티션과 같이 파티션별로 저장할 키 값 중에 NULL을 명시할 수도 있다.
- 레인지 파티션과 달리, 나머지 모든 값을 저장하는 MAXVALUE 파티션은 정의할 수 없다.

**리스트 파티션의 분리와 병합**

파티션의 레코드 건수가 많아져서 두 개 이상의 파티션으로 분리하거나 그 반대로 병합하려면 REOGANIZE PARTITION 명령을 사용하면 된다.

**리스트 파티션 주의사항**

- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없다.
- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있다.
- MySQL 5.1 버전에서는 정수 타입을 반환하는 표현식만 사용가능 했지만, MySQL 5.5 이상부터는 문자열 타입의 컬럼도 파티션 키로 사용할 수 있다.

### 10.3.3 해시 파티션

해시 파티션은 MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법이다.<br>
파티션 표현식의 결과 값을 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정하는 방식이다.<br>
해시 파티션의 파티션 키는 항상 정수 타입의 칼럼이거나 정수를 반환하는 표현식만 사용될 수 있다.<br>
해시 파티션에서 파티션을 추가하거나 삭제하는 작업에는 테이블 전체적으로 레코드를 재분배하는 작업이 따른다.<br>

**해시 파티션의 용도**

해시 파티션은 다음과 같은 특성을 지닌 테이블에 적합하다.

- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때

해시 파티션이나 이어서 설명할 키 파티션의 대표적인 용도로는 회원 테이블을 들 수 있다.<br>
이처럼 테이블의 데이터가 특정 칼럼의 값에 영향을 받지 않고, 전체적으로 비슷한 사용 빈도를 보일 때 적합한 파티션 방법이다.<br>

**해시 파티션 테이블 생성**

```sql
-- // 파티션의 개수만 지정할 때
CREATE TABLE employees (
	id INT NOT NULL,
	first_name VARCHAR(30),
	last_name VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	...
) ENGINE = INNODB
PARTITION BY HASH(id)
PARTITION 4;

-- // 파티션의 이름을 별도로 지정하고자 할 때
CREATE TABLE employees (
	id INT NOT NULL,
	first_name VARCHAR(30),
	last_name VARCHAR(30),
	hired DATE NOT NULL DEFAULT '1970-01-01',
	...
) ENGINE=INNODB
PARTITION BY HASH(id)
PARTITION 4 (
	PARTITION p0 ENGINE=INNODB
	PARTITION p1 ENGINE=INNODB,
	PARTITION p2 ENGINE=INNODB,
	PARTITION p3 ENGINE=INNODB,
);
```

- PARTITION BY HASH 키워드로 파티션 종류를 해시 파티션으로 지정
- PARTITION BY HASH 키워드 뒤에 파티션 키를 명시한다. 해시 파티션 키는 MySQL 서버 5.1 그리고 5.5 모두 정수 타입의 칼럼이나 표현식만 사용할 수 있다.
- PARTITION n 으로 몇 개의 파티션을 생성할 것인지 명시한다. 어떤 DBMS에서는 해시 파티션의 개수가 2n 이어야 한다는 제약조건이 있지만, MySQL의 해시 파티션에는 그런 제약이 없으며 파티션 개수의 1024보다 작은 값이면 된다.
- 파티션의 개수뿐 아니라 파티션의 이름을 명시하려면 위 예제의 두 번째 CREATE TABLE 명령과 같이 각 파티션을 나열하면 된다.
  하지만 해시나 키 파티션에는 특정 파티션을 삭제하거나 병합하는 작업의 거의 불필요하므로 파티션의 이름을 부여하는 것이 크게 의미가 없다.
  만약 파티션의 개수만 지정하면 각 파티션의 이름은 기본적으로 "p0, p1, p2, p3, ..." 과 같은 규칙으로 생성된다.

**해시 파티션과 분리와 병합**

리스트 파티션과는 달리, 대상 테이블의 모든 파티션에 저장된 레코드를 재분배하는 작업이 필요하다

**해시 파티션 추가**

해시 파티션은 테이블에 존재하는 파티션의 개수에 의해 파티션 알고리즘이 변하는 것이다.<br>
따라서 새로이 파티션이 추가된다면 기존의 각 파티션에 저장된 모든 레코드가 재배치돼야 한다.<br>
아래 예제와 같이 해시 파티션을 새로 추가할 때는 별도의 영역이나 범위는 명시하지 않고 몇 개의 파티션을 더 추가할 것인지만 지정하면 된다.<br>

```sql
-- // 파티션 1개만 추가하면서 파티션 이름을 부여하는 경우
ALTER TABLE employees ADD PARTITION(PARTITION p5 ENGINE=INNODB);
-- // 동시에 6개의 파티션을 별도의 이름 없이 추가하는 경우
ALTER TABLE clients ADD PARTITION PARTITIONS 6;
```

새로운 파티션을 추가하면 [그림 10-6] 과 같이 기존의 모든 파티션에 저장돼있던 레코드를 새로운 파티션으로 재분배하는 작업이 발생한다.

즉, 해시 파티션에서 파티션을 추가하거나 생성하는 작업은 많은 부하를 발생시킨다.

<img src="/partition/img/10-6.png" width="500px;" />

**해시 파티션 삭제**

해시나 키 파티션은 파티션 단위로 레코드를 삭제하는 방법이 없다.<br>
MySQL 서버가 지정한 파티션 키 값을 가공해서 데이터를 각 파티션으로 분산한 것이므로 각 파티션에 저장된 레코드가 어떤 부류의 데이터인지 사용자가 예측할 수 없다.<br>
결국 해시 파티션이나 키 파티션을 사용한 테이블에서 파티션 단위로 데이터를 삭제하는 작업은 의미도 없으며 해서도 안 될 작업이다.<br>

**해시 파티션 분할**

두 개 이상의 파티션으로 분할하는 기능은 없으며, 테이블 전체적으로 파티션의 개수를 늘리는 것만 가능하다.

**해시 파티션 병합**

해시나 키 파티션은 2개 이상의 파티션을 하나의 파티션으로 통합하는 기능을 제공하지 않는다.<br>
파티션의 개수를 줄이는 것만 가능하다.<br>
파티션 개수를 줄일 때는 COALESCE PARTITION 명령을 사용하면 된다.<br>

```sql
ALTER TABLE employees COALESCE PARTITION 1;
```

COALESCE PARTITION 뒤에 명시한 숫자 값은 줄이고자 하는 파티션의 개수를 의미한다.

<img src="/partition/img/10-7.png" width="500px;" />

**해시 파티션 주의사항**

- 특정 파티션 DROP 하는 것이 불가능하다.
- 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아니라 기존의 모든 데이터의 재배치 작업이 필요하다.
- 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문에 해시 파티션이 용도에 적합한 해결책인지 확인이 필요하다.
- 일반적으로 사용자들에게 익숙한 파티션의 조작이나 특성은 대부분 리스트 파티션이나 레인지 파티션에 제한적인 것들이 많다.
  해시 파티션이나 키 파티션을 사용하거나 조작할 때는 주의가 필요하다.

### 10.3.4 키 파티션

키 파티션은 해시 파티션과 사용법과 특성이 거의 같다.<br>
해시 파티션은 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시한다.<br>
키 파티션에서는 해시 값의 계산도 MySQL 서버가 수행한다.<br>
키 파티션에서는 정수 타입이나 정수 값을 반환하는 표현식뿐 아니라 거의 대부분의 데이터 타입에 대해 파티션 키를 적용할 수 있다.<br>
MySQL 서버는 선정된 파티션 키의 값을 MD5() 함수를 이용해 해시 값을 계산하고, 그 값을 MOD 연산해서 데이터를 각 파티션에 분배한다.<br>
이것이 키 파티션과 해시 파티션의 유일한 차이점이다.<br>

**키 파티션의 생성**

```sql
-- // 프라이머리 키가 있는 경우 자동으로 프라이머리 키가 파티션 키로 사용됨
CREATE TABLE k1 (
	id INT NOT NULL,
	name VARCHAR(20),
	PRIMARY KEY (id)
)
-- // 괄호의 내용을 비워두면 자동으로 프라이머리 키의 모든 칼럼이 파티션 키가 됨
-- // 그렇지 않고 프라이머리 키의 일부만 명시할 수도 있음
PARTITION BY KEY()
PARTITION 2;

-- // 프라이머리 키가 없는 경우 유니크 키(존재한다면)가 파티션 키로 사용됨
CREATE TABLE k1(
	id INT NOT NULL,
	name VARCHAR(20),
	UNIQUE KEY (id)
)

-- // 프라이머리 키나 유니크 키의 칼럼 일부를 파티션 키를 명시적으로 설정(MySQL 5.1.6 이상 버전)
CREATE TABLE dept_emp (
	emp_no INTEGER NOT NULL,
	dept_no CHAR(4),
	...
	PRIMARY KEY (dept_no, emp_no)
)
-- // 괄호의 내용에 프라이머리 키나 유니크 키를 구성하는 칼럼들 중에서
-- // 일부만 선택해 파티션 키로 설정하는 것도 가능하다.
PARTITION BY KEY(dept_no)
PARTITION 2;
```

- PARTITION BY KEY 키워드로 키 파티션을 정의
- PARTITION BY KEY 키워드 뒤에 파티션 키 컬럼을 명시한다.
  첫 번째나 두 번째 예제와 같이 PARTITION BY KEY()에 아무런 칼럼도 명시하지 않으면 MySQL 서버가 자동으로 프라이머리 키나 유니크 키의 모든 컬럼을 파티션 키로 선택한다.
  만약 테이블에 프라이머리 키가 있다면 프라이머리 키의 모든 칼럼으로, 프라이머리 키가 없는 경우에는 유니크 인덱스의 모든 칼럼으로 파티션 키를 구성한다.
- MySQL 5.1.6부터는 예제의 세 번째 쿼리와 같이 프라이머리 키나 유니크 키를 구성하는 칼럼들 중에서 일부만 파티션 키로 명시하는 것도 가능하다.
- PARTITION 키워드로 생성할 파티션 개수를 지정한다.

### 10.3.4.2 키 파티션의 주의 및 특이 사항

- 키 파티션은 MySQL 서버가 내부적으로 MD5() 함수를 이용해 파티셔닝하기 때문에 파티션 키가 반드시 정수 타입이 아니어도 된다.
  해시 파티션으로 파티셔닝이 어렵다면 키 파티션 적용을 고려해보자.
- MySQL 5.1.6 미만의 버전에서는 파티션 키를 프라이머리 키, 유니크 키의 모든 칼럼을 명시해야 한다.
  MySQL 5.1.6 부터는 프라이머리 키, 유니크 키를 구성하는 칼럼 중 일부만으로도 파티션 가능하다.
- 유니크 키를 파티션으로 사용할 때 유니크 키는 반드시 NOT NULL 이어야 한다.
- 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 때문에 키 파티션이 더 자주 사용된다.
