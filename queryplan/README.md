## 06. 실행 계획

> MySQL 에서는 EXPLAIN 이라는 명령으로 쿼리의 실행 계획을 확인할 수 있다.</br>
> 이번 장에서는 실행 계획에 표시되는 내용이 무엇을 의미하고 MySQL 서버가 내부적으로 어떤 작업을 하는지 자세히 살펴본다.</br>
> 그리고, 어떤 실행 계획이 좋고 나쁜지도 살펴 본다.

## 6.1 개요

실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아내고, 더욱 최적화된 방법으로 실행계획을 수립할 수 있도록 유도할 수 있다.

### 6.1.1 쿼리 실행 절차

쿼리가 실행되는 과정은 크게 3가지로 나눌수 있다.

1. 사용자로 부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리
2. SQL 의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
</br>
첫번째 단계를 "SQL Parsing" 이라고 하며, MySQL 서버의 "SQL 파서"라는 모듈로 처리한다.</br>
만약 SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다. 또한 "SQL 파스 트리"가 만들어 진다.</br>
MySQL 서버는 SQL 문장 그 자체가 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.</br>

두 번째 단계는 첫 번째 단계에서 만들어진 SQL 파스 트리를 참조하면서, 다음과 같은 내용을 처리한다. (이 밖의 수많은 처리를 하지만 대표적인 처리 작업)

- 불필요한 조건의 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

두 번째 단계는 "최적화 및 실행 계획 수립" 단계이며, MySQL 서버의 "옵티마이저"에서 처리한다.</br>
두 번째 단계가 완료되면 쿼리의 "실행 계획"이 만들어 진다.</br>

세 번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

<img src="/queryplan/img/6-1.png" width="500px;" />
[그림 6-1]은 "SQL 파서"와 "옵티마이저"가 MySQL 전체적인 아키텍처에서 어느 위치에 있는지 보여준다.

### 6.1.2 옵티마이저의 종류

옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당하고 있다.

DBMS가 선택하고 있는 비용 기반 최적화(Cost-based optimizer, CBO) 방법과 예전 오라클에서 많이 사용됐던 규칙 기반 최적화 방법(Rule-based optimizer, RBO)로 크게 나눠볼 수 있다.

- RBO는 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미한다.
  이 방식에는 통계 정보(테이블의 레코드 건수나 칼럼 값의 분포도)를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 향상 같은 실행 방법을 만들어 낸다.
- CBO는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출한다.
  이렇게 산출된 각 실행 방법별로 최소 비용이 소요되는 처리 방식을 선택해 최종 쿼리를 실행한다.

현재는 거의 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있으며, MySQL 역시 마찬가지 이다.

### 6.1.3 통계 정보

MySQL 에서 관리되는 통계 정보는 대략의 레코드 건수와 인덱스의 유니크한 값의 개수 정도가 전부이다.</br>
레코드 건수가 많지 않으면 통계 정보가 상당히 부정확한 경우가 많으므로 "ANALYZE" 명령을 이용해 강제적으로 통계 정보를 갱신해야 할 때도 있다.</br>
MEMORY 테이블은 별도로 통계 정보가 없으며, MyISAM과 InnoDB의 테이블과 인덱스 통계 정보는 다음과 같이 확인할 수 있다.</br>

```sql
SHOW TABLE STATUS LIKE 'tb_test'\G
SHOW INDEX FROM tb_test;
```

ANALYZE를 실행하는 동안 MyISAM 테이블은 읽기는 가능하지만 쓰기는 안된다.</br>
하지만 InnoDB 테이블은 읽기와 쓰기 모두 불가능하므로 서비스 도중에는 ANALYZE 을 실행하지 않는 것이 좋다.</br>
MyISAM 테이블의 ANALYZE 는 정확한 키값의 분포도를 위해 인덱스 전체를 스캔하므로 많은 시간이 소요되지만, InnoDB 테이블은 인덱스 페이지 중에서 8개 정도만 랜덤하게 선택해서 분석하고 그 결과를 인덱스의 통계 정보로 갱신한다.</br>

```
MySQL 5.1.38 이상의 InnoDB 플러그인 버전에서는 분석할 인덱스 페이지의 개수를 "innodb_stats_sample_pages" 파라미터로 지정할 수 있다.
Innodb 통계 수집을 위한 인덱스 페이지 개수는 기본값 8개에서 2~3배 이상을 벗어나지 않도록 설정하는 것이 좋다.
```

## 6.2 실행 계획 분석

MySQL 에서 쿼리의 실행 계획을 확인하려면 EXPLAIN 명령을 사용하면 된다.</br>
EXPLAIN 명령만 사용하면 기본적인 쿼리 실행 계획만 보이지만, EXPLAIN EXTENDED 나 EXPLAIN PARTITIONS 명령을 이용해 더 상세한 실행 계획을 확인할 수도 있다.</br>

```sql
EXPLAIN
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
LIMIT 10;
```

<img src="/queryplan/img/6-2.png" width="500px;" />

다른 DBMS 와 달리 MySQL에서는 필요에 따라 실행 계획을 산출하기 위해 쿼리의 일부분을 직접 실행할 때도 있다.</br>
때문에 쿼리 자체가 상당히 복잡하고 무거운 쿼리인 경우에는 실행 계획의 조회 또한 느려질 가능성이 있다.</br>
그리고 UPDATE, INSERT, DELETE 문장에 대해서는 실행 계획을 확인할 방법이 없다.</br>
UPDATE 나 INSERT, DELETE 문장의 실행 계획을 확인하려면 WHERE 조건절만 같은 SELECT 문장을 만들어서 대략적으로 계획을 확인해 볼 수 있다.</br>

## 6.4 실행 계획 분석 시 주의사항

### 6.4.1 Select_typee 칼럼의 주의 대상

DERIVED

- FROM 절에 사용된 서브 쿼리로부터 발생한 임시 테이블을 의미. 임시 테이블은 데이터의 양에 따라 메모리나 디스크에 저장될 수 있는데, 메모리에 저장되게되면 성능에는 큰 영향이 없지만 데이터가 커서 디스크에 저장되게 되면 성능이 저하된다.

UNCACHEABLE SUBQUERY

- 쿼리의 FROM 절 이외의 부분에서 사용하는 서브 쿼리는 가능하면 MySQL 옵티마이저가 최대한 캐시되어 재사용 될 수 있게 유도한다.
  하지만 사용자 변수나 일부 함수가 사용된 경우에는 이러한 캐시 기능을 사용할 수 없게 된다. 이런 실행 계획이 사용된다면 최적화에 대해 고민이 필요하다.

DEPENDENT SUBQUERY

- 쿼리의 FROM 절 이외의 부분에서 사용하는 서브 쿼리가 자체적으로 실행되지 못하고, 외부 쿼리에서 값을 전달받아 실행되는 경우 DEPENDENT SUBQUERY 가 표시된다.
  이는 서브 쿼리가 먼저 실행되지 못하고 서브 쿼리가 외부 쿼리에 의존적이기 때문에 전체 쿼리의 성능을 느리게 만든다. 최대한 외부 쿼리와의 의존도를 제거하는 것이 좋다.

### 6.4.2 Type 칼럼의 주의 대상

ALL, index

- index 는 인덱스 풀 스캔을 의미하며, ALL 은 풀 테이블 스캔을 의미한다.
  둘 다 대상의 차이만 있지 전체 레코드를 대상으로 작업하는 방식이라 빠르게 결과를 가져오기는 어렵다.
  일반적인 OLTP 환경에 적합한 접근 방식은 아니므로 새로운 인덱스를 추가하거나 쿼리의 요건을 변경해서 이러한 접근 방법을 제거하는 것이 좋다.

### 6.4.3 Key 칼럼의 주의 대상

쿼리가 인덱스를 사용하지 못할 때 실행 계획의 Key 칼럼에 아무 값도 표시되지 않는다.</br>
쿼리가 인덱스를 사용할 수 있도록 인덱스를 추가하거나, WHERE 조건을 변형하는 것이 좋다.

### 6.4.4 Rows 칼럼의 주의 대상

- 쿼리가 실제로 가져오는 레코드 수보다 훨씬 더 큰 값이 Rows 칼럼에 표시되는 경우에는 인덱스를 정상적으로 사용하고 있는지, 그 인덱스가 충분히 작업 범위를 좁혀 줄 수 있는 컬럼으로 구성됐는지 검토해보는 것이 좋다.
- Rows  컬럼의 수치를 판단할 때 주의해야 할 점은 LIMIT가 포함된 쿼리라 하더라도 LIMIT 제한은 Rows 칼럼의 고려 대상에서 제외된다는 것이다.
  즉, "Limit 1" 로 1 건만 SELECT 하는 쿼리라 하더라도 Rows 칼럼에는 훨씬 큰 수치가 표현될 수 있으며, 성능상 아무런 문제가 없고 최적화된 쿼리 일수도 있다.

### 6.4.5 Extra 칼럼의 주의 대상

쿼리를 실행하면서 처리한 주요 작업에 대한 내용이 표시되기 때문에 쿼리를 튜닝할 때 중요한 단서가 되는 내용이 많다.</br>
주요 키워드는 기억했다가 실행 계획상에 해당 단어가 표시될 때는 더 자세히 검토 해보는 것이 좋다.</br>

쿼리가 요건을 제대로 반영하고 있는지 확인해야 하는 경우

- Full scan on Null key
- Impossible HAVING
- Impossible WHERE
- Impossible WHERE noticed affter reading const tables
- No matching min/max row
- No matching row in const table
- Unique row not found

위와 같은 코멘트가 Extra 칼럼에 표시된다면 우선 쿼리가 요건에 제대로 반영해서 작성됐거나 버그가 생길 가능성은 없는지 확인해야 한다.</br>
이 항목들은 성능과 관계가 깊지 않고 단지 "그런 레코드 없음" 이라는 의미가 강하기 때문에 이 쿼리로 버그의 가능성이 있을지를 집중적으로 검토하는 것이 좋다.</br>
물론 업무적인 요건을 제대로 반영한다면 무시해도 상관없다.</br>

쿼리의 실행 계획이 좋지 않은 경우

- Range chcked for each record (index map : N)
- Using filesort
- Using join buffer
- Using temporary
- Using where

위 코멘트가 표시된다면 쿼리를 더 최적화 할 수 있는지 검토해보는 것이 좋다.</br>
쿼리의 실행 계획에서 이러한 문구가 사라질 수 있다면 최선이겠지만 그렇지 않더라도 성능상 허용 가능하다면 넘어가도 좋다.</br>

쿼리 실행이 좋을 경우

- Distinct
- Using index
- Using index for group-by

위 코멘트는 쿼리가 최적화 되어 처리되고 있음을 알려주는 지표이다.</br>
특히 Using index 는 쿼리가 커버링 인덱스로 처리되고 있음을 알려주는데, MySQL 에서 제공할 수 있는 최고의 성능을 사용하고 있다는 것이다.</br>
