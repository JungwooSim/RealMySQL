## 05. 인덱스
> MySQL에서 사용 가능한 인덱스의 종류 및 특성을 알아본다.

## 5.1 디스크 읽기 방식

### 5.1.1 저장 매체

**일반적으로 서버에 사용되는 저장 매체는 아래와 같이 구분된다.**
- 내장 디스크(Internal Disk)
- DAS(Direct Attached Storage)
    - 내장 디스크 용량문제를 해결하기 위해 주로 사용하는 것으로 컴퓨터 본체와 달리 디스크만 있는 것이 특징이다.
    - 하나의 컴퓨터 본체에만 연결해서 사용할 수 있기 때문에 디스크 정보를 여러 컴퓨터가 동시에 공유하는 것이 불가능하다.
- NAS(Network Attached Storage)
- SAN(Storage Area Network)

내장 디스크와 DAS의 문제점을 동시에 해결하기 위해 주로 NAS와 SAN을 사용한다.<br>
DAS와 NAS의 가장 큰 차이는 여러 컴퓨터에서 동시에 사용할 수 있는지와 컴퓨터 본체와 연결되는 방식이다.<br>
NAS는 TCP/IP를 통해 연결된다. NAS는 동시에 여러 컴퓨터에서 공유해서 사용할 수 있는 저장매체이지만 SATA나 SAS 방식의 직접 연결보다는 속도가 매우 느리다.<br>
SAN은 DAS로 구축할 수 없는 대용량의 스토리지 공간을 제공하는 장치이다.<br>
SAN은 여러 컴퓨터에서 동시에 사용할 수 있을뿐더러 컴퓨터 본체와 광케이블로 연결되기 때문에 상당히 빠르고 안정적인 데이터

## 5.2 인덱스란?

칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-Value pair)으로 인덱스를 만들어 두는 것이다.<br>
칼럼의 값을 주어진 순서로 미리 정렬해서 보관하는 것이다.<br>
결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 대신 데이터의 읽기 속도를 높이는 기능이다.<br>
인덱스를 역할별로 구분하면 프라이머리 키(Primary Key)와 보조 키(Secondary Key)로 구분해 볼 수 있다.<br>

**프라이머리 키(Primary Key)**

그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미<br>
테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 우리는 이를 식별자라고도 부른다.<br>
NULL 값을 허용하지 않으며 중복을 허용하지 않는 것이 특징이다.<br>

**보조 키(Secondary Key)**

프라이머리 키를 제외한 나머지 모든 인덱스는 보조 인덱스(Secondary Index)로 분류한다.<br>
데이터 저장 방식(알고리즘)별로 구분하자면 많은 분류로 가능하겠지만, 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다. 최근에는 새롭게 Fractal-Tree 인덱스와 같은 알고리즘도 추가되었다.<br>

- B-Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘이다.
매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 전방(Prefix) 일치와 같이 값의 일부만 검색하고자 할 때는 사용할 수 없다.
- Fractal-Tree 알고리즘은 B-Tree 알고리즘의 단점을 보완하기 위해 고안된 알고리즘이다.
데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게 설계된 것이 특징이다.

### 5.3 B-Tree 인덱스 (Balanced Tree)

B-Tree는 칼럼의 원래 값을 변형시키지 않고 (값의 앞부분만 잘라서 관리하기는 함) 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다. 처리(읽고 쓰기)를 보장해준다. 하지만 그만큼 고가의 비용이 발생한다.

### 5.3.1 구조 및 특성

데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리하는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.<br>
그림 5-6은 B-Tree 인덱스의 각 노드와 데이터 파일의 관계를 표현한 것이다.<br>

<img src="/index/img/5-6.png" width="500px;" />

InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장된다.<br>
InnoDB에서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이블이 생성된다.<br>
클러스터링이란 비슷한 값들을 최대한 모아서 저장하는 방식을 의미한다.

### 5.3.2 B-Tree 인덱스 키 추가 및 삭제

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.<br>

**인덱스 키 추가**

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.<br>
저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.<br>
만약 리프 노드가 꽉차서 더는 저장할 수 없을 때는 리프 노드가 분리(Split)돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.<br>
이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.<br>
MyISAM이나 Memory 스토리지 엔진을 사용하는 테이블에서 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 반영한다.<br>
즉, B-Tree에 키를 추가하는 작업이 완료될 때까지 클라이언트는 쿼리의 결과를 받지 못하고 기다리게 된다.<br>
InnoDB 스토리지 엔진은 [그림 5-8] 과 같이 상황에 따라 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지, 아니면 바로 처리할지 결정하게 된다.<br>

<img src="/index/img/5-8.png" width="500px;" />

1. 사용자의 쿼리 실행
2. InnoDB의 버퍼 풀에 새로운 키 값을 추가해야 할 페이지(B-Tree의 리프 노드)가 존재한다면 즉시 키 추가 작업 처리
3. 버퍼 풀에 B-Tree의 리프 노드가 없다면 인서트 버퍼에 추가할 키값과 레코드의 주소를 임시로 기록해 두고 작업 완료(사용자의 쿼리는 실행 완료됨)
4. 백그라운드 작업으로 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키값이 있는지 확인한 후, 있다면 병합함(B-Tree에 인덱스 키와 주소를 저장)
5. 데이터베이스 서버 자원의 여유가 생기면 MySQL 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키와 주소 값을 머지(B-Tree에 인덱스 키와 주소를 저장) 시킴

**인덱스 키 삭제**

삭제는 간단하다. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.<br>
이렇게 삭제된 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 또는 재활용할 수 있다.<br>
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O가 필요한 작업이다.<br>
MyISAM이나 Memory 스토리지 엔진의 테이블에서는 인서트 버퍼와 같은 기능이 없으므로 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.<br>

**인덱스 키 변경**

B-Tree의 키값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리 된다.

**인덱스 키 검색**

INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서다.<br>
인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 "트리 탐색(Tree traversal)"이라고 한다.<br>
부등호("<>") 비교나 값의 뒷부분이 일치하는 경우에는 B-Tree 인덱스를 이용한 검색이 불가능하다. 또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다는 것이다.<br>
함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의해야 한다.<br>
InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락(갭 락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.<br>
따라서 UPDATE 나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.<br>

### 5.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본단위를 페이지(Page) 또는 블록(Block)이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.<br>
페이지는 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. 인덱스도 결국은 페이지 단위로 관리되며, 위의 B-Tree 그림에서 루트와 브랜치, 그리고 리프(Leaf) 노드를 구분한 기준이 바로 페이지 단위이다.<br>
DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. MySQL의 B-Tree는 자식 노드는 인덱스의 페이지 크기와 키 값에 크기에 따라 결정된다.<br>
인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.<br>
인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스 크기가 커진다는 것을 의미한다.<br>
인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 커질수록 메모리(버퍼 풀이나 캐시)에 캐시해 둘 수 있는 레코드 수는 줄어들 것을 의미한다. 자연히 메모리의 효율이 떨어지게 되는 결과를 가져온다.<br>

**B-Tree 깊이**

B-Tree 인덱스의 깊이(Depth)는 상당히 중요하지만 직접적으로 제어할 방법이 없다.<br>
인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 작아지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이(Depth)가 깊어져서 **디스크 읽기가 더 많이 필요하게 된다.**<br>
위 내용은 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다는 것을 강조하기 위함이고, 실제로는 아무리 대용량의 데이터베이스라도 B-Tree의 깊이(Depth)가 4~5 이상까지 깊어지는 경우는 거의 발생하지 않는다.<br>

**선택도(기수성)**

인덱스에서 선택도(Selectivy) 또는 기수성(Cardinality)는 거의 같은 의미로 사용되며, **모든 인덱스 키값 가운데 유니크한 값의 수를 의미**한다.<br>
인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

**읽어야 하는 레코드의 건수**

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.<br>
테이블에 레코드가 100만 건이 저장돼 있는데, 그 중에서 50만 건을 읽어야 하는 쿼리가 있다고 가정해보자.<br>
이 작업은 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지, 인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단해야 한다.<br>
인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있는데, 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 많이 드는 작업인 것으로 예측한다.<br>
즉, 인덱스를 통해 읽어야할 레코드의 건수(물론 옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.<br>
