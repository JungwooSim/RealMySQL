## 05. 인덱스
> MySQL에서 사용 가능한 인덱스의 종류 및 특성을 알아본다.

## 5.1 디스크 읽기 방식

### 5.1.1 저장 매체

**일반적으로 서버에 사용되는 저장 매체는 아래와 같이 구분된다.**
- 내장 디스크(Internal Disk)
- DAS(Direct Attached Storage)
    - 내장 디스크 용량문제를 해결하기 위해 주로 사용하는 것으로 컴퓨터 본체와 달리 디스크만 있는 것이 특징이다.
    - 하나의 컴퓨터 본체에만 연결해서 사용할 수 있기 때문에 디스크 정보를 여러 컴퓨터가 동시에 공유하는 것이 불가능하다.
- NAS(Network Attached Storage)
- SAN(Storage Area Network)

내장 디스크와 DAS의 문제점을 동시에 해결하기 위해 주로 NAS와 SAN을 사용한다.<br>
DAS와 NAS의 가장 큰 차이는 여러 컴퓨터에서 동시에 사용할 수 있는지와 컴퓨터 본체와 연결되는 방식이다.<br>
NAS는 TCP/IP를 통해 연결된다. NAS는 동시에 여러 컴퓨터에서 공유해서 사용할 수 있는 저장매체이지만 SATA나 SAS 방식의 직접 연결보다는 속도가 매우 느리다.<br>
SAN은 DAS로 구축할 수 없는 대용량의 스토리지 공간을 제공하는 장치이다.<br>
SAN은 여러 컴퓨터에서 동시에 사용할 수 있을뿐더러 컴퓨터 본체와 광케이블로 연결되기 때문에 상당히 빠르고 안정적인 데이터

## 5.2 인덱스란?

칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-Value pair)으로 인덱스를 만들어 두는 것이다.<br>
칼럼의 값을 주어진 순서로 미리 정렬해서 보관하는 것이다.<br>
결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 대신 데이터의 읽기 속도를 높이는 기능이다.<br>
인덱스를 역할별로 구분하면 프라이머리 키(Primary Key)와 보조 키(Secondary Key)로 구분해 볼 수 있다.<br>

**프라이머리 키(Primary Key)**

그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미<br>
테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 우리는 이를 식별자라고도 부른다.<br>
NULL 값을 허용하지 않으며 중복을 허용하지 않는 것이 특징이다.<br>

**보조 키(Secondary Key)**

프라이머리 키를 제외한 나머지 모든 인덱스는 보조 인덱스(Secondary Index)로 분류한다.<br>
데이터 저장 방식(알고리즘)별로 구분하자면 많은 분류로 가능하겠지만, 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다. 최근에는 새롭게 Fractal-Tree 인덱스와 같은 알고리즘도 추가되었다.<br>

- B-Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘이다.
매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 전방(Prefix) 일치와 같이 값의 일부만 검색하고자 할 때는 사용할 수 없다.
- Fractal-Tree 알고리즘은 B-Tree 알고리즘의 단점을 보완하기 위해 고안된 알고리즘이다.
데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게 설계된 것이 특징이다.

### 5.3 B-Tree 인덱스 (Balanced Tree)

B-Tree는 칼럼의 원래 값을 변형시키지 않고 (값의 앞부분만 잘라서 관리하기는 함) 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다. 처리(읽고 쓰기)를 보장해준다. 하지만 그만큼 고가의 비용이 발생한다.

### 5.3.1 구조 및 특성

데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리하는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.<br>
그림 5-6은 B-Tree 인덱스의 각 노드와 데이터 파일의 관계를 표현한 것이다.<br>

<img src="/index/img/5-6.png" width="500px;" />

InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장된다.<br>
InnoDB에서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이블이 생성된다.<br>
클러스터링이란 비슷한 값들을 최대한 모아서 저장하는 방식을 의미한다.

### 5.3.2 B-Tree 인덱스 키 추가 및 삭제

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.<br>

**인덱스 키 추가**

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.<br>
저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.<br>
만약 리프 노드가 꽉차서 더는 저장할 수 없을 때는 리프 노드가 분리(Split)돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.<br>
이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.<br>
MyISAM이나 Memory 스토리지 엔진을 사용하는 테이블에서 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 반영한다.<br>
즉, B-Tree에 키를 추가하는 작업이 완료될 때까지 클라이언트는 쿼리의 결과를 받지 못하고 기다리게 된다.<br>
InnoDB 스토리지 엔진은 [그림 5-8] 과 같이 상황에 따라 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지, 아니면 바로 처리할지 결정하게 된다.<br>

<img src="/index/img/5-8.png" width="500px;" />

1. 사용자의 쿼리 실행
2. InnoDB의 버퍼 풀에 새로운 키 값을 추가해야 할 페이지(B-Tree의 리프 노드)가 존재한다면 즉시 키 추가 작업 처리
3. 버퍼 풀에 B-Tree의 리프 노드가 없다면 인서트 버퍼에 추가할 키값과 레코드의 주소를 임시로 기록해 두고 작업 완료(사용자의 쿼리는 실행 완료됨)
4. 백그라운드 작업으로 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키값이 있는지 확인한 후, 있다면 병합함(B-Tree에 인덱스 키와 주소를 저장)
5. 데이터베이스 서버 자원의 여유가 생기면 MySQL 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키와 주소 값을 머지(B-Tree에 인덱스 키와 주소를 저장) 시킴

**인덱스 키 삭제**

삭제는 간단하다. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.<br>
이렇게 삭제된 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 또는 재활용할 수 있다.<br>
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O가 필요한 작업이다.<br>
MyISAM이나 Memory 스토리지 엔진의 테이블에서는 인서트 버퍼와 같은 기능이 없으므로 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.<br>

**인덱스 키 변경**

B-Tree의 키값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리 된다.

**인덱스 키 검색**

INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서다.<br>
인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 "트리 탐색(Tree traversal)"이라고 한다.<br>
부등호("<>") 비교나 값의 뒷부분이 일치하는 경우에는 B-Tree 인덱스를 이용한 검색이 불가능하다. 또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다는 것이다.<br>
함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의해야 한다.<br>
InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락(갭 락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.<br>
따라서 UPDATE 나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.<br>

### 5.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본단위를 페이지(Page) 또는 블록(Block)이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.<br>
페이지는 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. 인덱스도 결국은 페이지 단위로 관리되며, 위의 B-Tree 그림에서 루트와 브랜치, 그리고 리프(Leaf) 노드를 구분한 기준이 바로 페이지 단위이다.<br>
DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. MySQL의 B-Tree는 자식 노드는 인덱스의 페이지 크기와 키 값에 크기에 따라 결정된다.<br>
인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.<br>
인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스 크기가 커진다는 것을 의미한다.<br>
인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 커질수록 메모리(버퍼 풀이나 캐시)에 캐시해 둘 수 있는 레코드 수는 줄어들 것을 의미한다. 자연히 메모리의 효율이 떨어지게 되는 결과를 가져온다.<br>

**B-Tree 깊이**

B-Tree 인덱스의 깊이(Depth)는 상당히 중요하지만 직접적으로 제어할 방법이 없다.<br>
인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 작아지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이(Depth)가 깊어져서 **디스크 읽기가 더 많이 필요하게 된다.**<br>
위 내용은 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다는 것을 강조하기 위함이고, 실제로는 아무리 대용량의 데이터베이스라도 B-Tree의 깊이(Depth)가 4~5 이상까지 깊어지는 경우는 거의 발생하지 않는다.<br>

**선택도(기수성)**

인덱스에서 선택도(Selectivy) 또는 기수성(Cardinality)는 거의 같은 의미로 사용되며, **모든 인덱스 키값 가운데 유니크한 값의 수를 의미**한다.<br>
인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

**읽어야 하는 레코드의 건수**

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.<br>
테이블에 레코드가 100만 건이 저장돼 있는데, 그 중에서 50만 건을 읽어야 하는 쿼리가 있다고 가정해보자.<br>
이 작업은 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지, 인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단해야 한다.<br>
인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있는데, 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 많이 드는 작업인 것으로 예측한다.<br>
즉, 인덱스를 통해 읽어야할 레코드의 건수(물론 옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.<br>

### 5.3.4 B-Tree 인덱스를 통한 데이터 읽기

MySQL이 인덱스를 이용하는 대표적인 방법 3가지를 소개한다.

**인덱스 레인지 스캔**

<img src="/index/img/5-9.png" width="500px;" />

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.<br>
[그림 5-9]에서 알 수 있듯이 루트 노드에서 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 실제로 원하는 시작 지점을 찾을 수 있다.<br>
일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.<br>
B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많은데, 이 과정을 좀 더 자세히 보자.<br>

<img src="/index/img/5-10.png" width="500px;" />

그림에서 중요한 것은 [그림 5-10]에서 중요한 것은 인덱스의 리프 노드에서 검색 조건에 일치하는 건들을 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.<br>
이 때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한번씩 실행된다.<br>
인덱스를 통해 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류되는 것이다.<br>

**인덱스 풀 스캔**

인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스킨이라고 한다.<br>
대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.<br>

<img src="/index/img/5-11.png" width="500px;" />

먼저 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 링크드 리스트(Linked list, 리프 노드를 연결하는 세로로 그려진 두쌍씩의 화살표)를 따라서 처음부터 끝까지 스캔하는 방식을 인덱스 풀 스캔이라고 한다. 인덱스 레인지보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.

**루스 인덱스 스캔**

느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.

<img src="/index/img/5-12.png" width="500px;" />

루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간마다 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.<br>
일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다.<br>

### 5.3.5 다중 컬럼(Multi-column) 인덱스

두 개 이상의 컬럼으로 구성된 인엑스를 다중 칼럼 인덱스라고 하며, 또한 2개 이상의 컬럼이 연결됐다고해서 "Concatenated Index"라고도 한다.

<img src="/index/img/5-13.png" width="500px;" />

인덱스 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다. 즉, 두 번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 레코드에만 의미가 있다는 것이다.<br>
만약 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에 의존해서 정렬되고 네 번째 칼럼은 다시 세번째 칼럼에 의존해서 정렬 된다.<br>
다중 컬럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며 또한 아주 신중히 결정해야 하는 이유가 바로 여기에 있다.<br>

### 5.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정된다.

**인덱스의 정렬**

인덱스를 구성하는 칼럼 가운데 오름차순(ASC)과 내림차순(DESC)를 혼합해서 만들어야 할 때가 있다.<br>
MySQL에서는 칼럼의 값을 역으로 변환해서 구현하는 것이 유일한 방법이다.<br>

**인덱스 스캔 방향**

<img src="/index/img/5-14.png" width="500px;" />

인덱스를 역순으로 정렬되게 할 수 없지만 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.<br>
인덱스를 오름차순으로 읽으면 최종적으로 출력되는 결과 레코드는 자동으로 오름차순으로 정렬된 결과이며, 내림차순으로 읽으면 그 결과는 내림차순으로 정렬된 상태가 되는 것이다.<br>
쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 최적화가 필요한 경우, MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.<br>

### 5.3.7 B-Tree 인덱스의 가용성과 효율성

쿼리의 WHERE 조건이나 GROUP BY 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.<br>
여기서는 어떤 조건에서 인덱스를 사용할 수 있고 어떨 때 사용할 수 없는지 살펴 본다.<br>

**비교 조건의 종류와 효율성**

다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교("=") 인지 아니면 크다(">") 또는 작다("<")와 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.<br>
공식적인 명칭은 아니지만 작업의 범위를 결정하는 조건을 "작업 범위 결정 조건"이라 하고, 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 "필터링 조건" 또는 "체크 조건"이라고 표현한다.<br>
작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 (최종적으로 가져오는 레코드는 작게 만들지 몰라도) 쿼리의 처리 성능을 높이지 못한다. 오히러 쿼리 실행을 더 느리게 만들 때가 많다.<br>

**인덱스의 가용성**

B-Tree 인덱스의 특징은 왼쪽 값에 기준(Left-most)해서 오른쪽 값이 정렬돼 있다는 것이다. 여기서 왼쪽이라 함은 하나의 칼럼 내에서뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 적용된다.

<img src="/index/img/5-16.png" width="500px;" />

```sql
SELECT * FROM employees WHERE first_name LIKE '%mer';
```

이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없다. 이유는 first_name 칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상수값("%mer")에는 왼쪽 부분이 고정되지 않았기 때문이다.

```sql
SELECT * FROM dept_emp WHERE emp_no >= 10144;
```

위 쿼리는 인덱스가 (dept_no, emp_no) 칼럼 순서대로 생성돼 있다면 인덱스의 선행 칼럼인 dept_no 값 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.

케이스 B의 인덱스는 다중 칼럼으로 인덱스가 만들어졌기 때문에 dept_no에 대해 먼저 정렬한 후, 다시 emp_no 칼럼값으로 정렬돼 있기 때문이다.

**가용성과 효율성 판단**

기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다. 여기서 사용할 수 없다는 것은 작업 범위 결정 조건으로 사용할 수 없다는 것을 의미하며, 경우에 따라서는 체크 조건으로 인덱스를 사용할 수 있다.

- NOT-EQUAL 로 비교된 경우 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")

    ```sql
    ... WHERE column <> 'N'
    ... WHERE column NOT IN (10, 11, 12)
    ... WHERE column IS NOT NULL
    ```

- LIKE '%??' (앞부분이 아닌 뒷부분이 불일치) 형태로 문자열 패턴이 비교된 경우

    ```sql
    ... WHERE column LIKE '%승환'
    ... WHERE column LIKE '_승환'
    ... WHERE column LIKE '%승%'
    ```

- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우

    ```sql
    ... WHERE SUBSTRING(column, 1, 1) = 'X'
    ... WHERE DAYOFMONTH(column) = 1
    ```

- 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변형해야 비교가 가능한 경우)

    ```sql
    ... WHERE char_column = 10
    ```

- 문자열 데이터 타입의 콜레이션이 다른 경우

    ```sql
    ... WHERE utf8_bin_char_column = eukr_bin_char_column
    ```

MySQL에서는 NULL 값도 인덱스로 관리된다. 다음과 같은 WHERE 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.

```sql
... WHERE column IS NULL ..
```

다중 칼럼으로 만들어진 어떤 조건에서 사용될 수 있고, 어떤 경우에는 절대 사용될 수 없는지 살펴보자. 다음과 같은 인덱스가 있다고 가정해보자.

Index ix_text (column_1, column_2, column_3, ... , column_n)

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
  - column_1 칼럼에 대한 조건이 없는 경우
  - column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우( i 는 2보다 크고 n보다 작은 임의의 값을 의미)
  - column_1 ~ column_(i-1) 칼럼까지 Equal 형태("=" 또는 "IN")로 비교
  - column_i 칼럼에 대한 다음 연산자 중 하나로 비교

      ```sql
      Equal("=" 또는 "IN")
      크다 작다 형태(">" 또는 "<")
      LIKE 로 좌측 일치 패턴(LIKE "승환%")
      ```

인덱스를 사용하는 경우와 그렇지 않은 상황에 해당하는 쿼리의 조건 몇가지를 예제로 살펴보자.

```sql
// 다음 쿼리는 인덱스를 사용할 수 없다.
... WHERE column_1 <> 2

// 다음 쿼리는 column_1과 column_2까지 범위 결정 조건으로 사용됨
... WHERE column_1 = 1 AND column_2 > 10

// 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로 사용됨
... WHERE column_1 IN (1,2) AND column_2 = 2 AND column_3 <= 10

// 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로, column_4 는 체크 조건으로 사용됨
... WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10, 20, 30) AND column_4 <> 100

// 다음 쿼리는 column_1, column_2, column_3, column_4 까지 범위 결정 조건으로 사용됨
// 좌측 패턴 일치 LIKE 비교는 크다 또는 작다 비교와 동급으로 생각하면 될 듯하다.
... WHERE column_1 = 1 AND column_2 IN (2,4) AND column_3 = 30 AND column_4 LIKE '김승%'

// 다음 쿼리는 column_1, column_2, column_3, column_4, column_5 모두 범위 결정 조건으로 사용됨
... WHERE column_1 = 1 AND column_2 = 2 AND column_3 = 30 AND column_4 = '김승환' AND column_5 = '서울'
```

여기까지의 내용은 모두 B-Tree 인덱스의 특징이므로 MySQL뿐 아니라 대부분의 RDBMS에도 동일하게 적용된다.

## 5.4 해시(Hash) 인덱스

해시 인덱스는 동등 비교 검색에는 최적화돼 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다.

### 5.4.1 구조 및 특성

<img src="/index/img/5-17.png" width="500px;" />

장점은 실제 키값과는 관계 없이 인덱스 크기가 작고 검색이 빠르다는 것이다.<br>
[그림 5-17] 을 보면 알다시피 트리 형태의 구조가 아니므로 검색하고자 하는 값을 주면 해시 함수를 거쳐서 찾고자 하는 키값이 포함된 버켓을 알아낼 수 있다.<br>
그리고 그 버켓 하나만 읽어서 비교해보면 실제 레코드가 저장된 위치를 바로 알 수 있다. 그래서 트리 내에서 여러 노드를 읽어야 하지만 레코드의 주소를 알아 낼 수 있는 B-Tree보다 상당히 빨리 결과를 가져올 수 있다.<br>

```
B-Tree 인덱스나 해시 인덱스 모두 각 키값과 레코드 주소값 등의 정보를 저장해 두는 공간이 필요하다.
이 저장 공간은 작업의 기본 단위가 고정된 크기로 할당된다. B-Tree에서는 이처럼 고정된 크기의 저장 공간을 노드라고 하며, 해시 인덱스에서는 이를 버켓이라고 한다.
버켓은 크게 중요한 개념은 아니므로 키 값이 저장된 단위 크기의 메모리 공간으로 이해하면 된다.
```

해시 인덱스는 원래의 키값을 저장하는 것이 아니라 함수의 결과(일반적으로는 단순 숫자값)만 저장하므로 키 칼럼의 값이 아무리 길어도 실제 해시 인덱스에 저장되는 값은 4~8바이트 수준으로 상당히 줄어든다. 그래서 해시 인덱스는 B-Tree 인덱스보다는 상당히 작은 편이다.

```
해시 알고리즘은 DBMS에서는 대표적으로 검색을 위한 인덱스와 테이블의 파티셔닝 용도로 사용된다.
검색을 위해 해시 알고리즘이 사용되는 경우에는 해시 함수의 결과 값이 범위가 넓어야 충돌이 줄어들고 그만큼 검색 성능이 높아진다.
하지만 테이블의 파티셔닝 용도로 사용되는 경우에는 해시 함수가 필요한 파티션의 개수만큼만 만들어내도록 설계해야 하므로 해시 함수의 결과 값의 범위를 좁게 사용한다.
MySQL의 해시 파티션은 이러한 해시 알고리즘을 이용해 테이블을 파티셔닝하는 기능이다.
```

### 5.4.2 해시 인덱스의 가용성 및 효율성

해시 인덱스는 빠른 검색을 제공하지만 키값 자체가 변환되어 저장되기 때문에 범위를 검색하거나 원본값 기준으로 정렬할 수 없다.<br>
해시 인덱스의 효율성을 살펴본다.<br>

**작업 범위 제한 조건으로 해시 인덱스를 사용하는 쿼리**

다음 패턴의 쿼리는 동등 비교 조건으로 값을 검색하고 있으므로 해시 인덱스의 빠른 장점을 그대로 이용할 수 있다.<br>
IN 연산자도 여러 개의 동등 비교로 풀어서 처리할 수 있기 때문에 같은 효과를 얻을 수 있다.<br>

```sql
SELECT ... FROM tb_hash WHERE column = '검색어';
SELECT ... FROM tb_hash WHERE column <=> '검색어';
SELECT ... FROM tb_hash WHERE column IN ('검색어1', '검색어2');
SELECT ... FROM tb_hash WHERE column IS NULL;
SELECT ... FROM tb_hash WHERE column IS NOT NULL;
```

"<=>" 는 "NULL-Safe Equal" 연산자라고 하는데, 비교 양쪽의 값이 NULL이 있을 때를 제외하고는 "=" 연산자와 똑같다.<br>

**해시 인덱스를 전혀 사용하지 못하는 쿼리**

아래와 같은 형태의 크다 또는 작다 기반의 검색은 어떠한 방법으로도 해시 인덱스를 사용할 수 없다.<br>
즉, 작업 범위 결정 조건뿐 아니라 체크 조건의 용도로도 전혀 사용할 수 없다. 대체로 범위 비교나 부정형 비교는 해시 인덱스를 사용할 수 없다.<br>

```sql
SELECT ... FROM tb_hash WHERE column >= '검색어';
SELECT ... FROM tb_hash WHERE column BETWEEN 100 AND 120;
SELECT ... FROM tb_hash WHERE column LIKE '검색어%';
SELECT ... FROM tb_hash WHERE column <> '검색어';
```

해시 인덱스를 사용할 때 주의할 점이 있다. 다중 컬럼으로 생성된 해시 인덱스에서도 모든 칼럼이 동등 조건으로 비교되는 경우에만 인덱스를 사용할 수 있다는 점이다.

## 5.5 R-Tree 인덱스

MySQL의 공간 인덱스(Spatial Index)는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다.

기본적인 내부 매커니즘은 B-Tree와 흡사하다.

B-Tree는 인덱스를 구성하는 칼럼의 값이 1차원의 스칼라값인 반면, R-Tree 인덱스는 2차원 공간 개념 값이라는 것이다.

GIS와 GPS에 기반을 둔 서비스에서 사용된다.

MySQL의 공간 확장에는 아래와 같이 크게 3가지 기능이 포함돼 있다.

- 공간 데이터를 저장할 수 있는 데이터 타입
- 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
- 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

### 5.5.1 구조 및 특성

<img src="/index/img/5-18.png" width="500px;" />

[그림 5-18]은 MySQL에서 지원하는 데이터 타입이다.

마지막에 있는 GEOMETRY 타입은 나머지 3개 타입의 수퍼 타입으로, POINT와 LINE, 그리고 POLYGON 객체 모두 저장할 수 있다.<br>
공간 정보의 검색을 위한 R-Tree 알고리즘을 이해하려면 MBR이라는 개념을 알고 있어야 한다.<br>
MBR 은 Minimum Bounding Rectangle의 약자로 해당 도형을 감싸는 최소 크기의 사각형을 의미하는데, 이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스다.<br>

<img src="/index/img/5-21.png" width="500px;" />

<img src="/index/img/5-22.png" width="500px;" />

[그림 5-22]와 같이 R-Tree 인덱스의 내부를 표현할 수 있다.

### 5.5.2 R-Tree 인덱스의 용도

MBR 정보를 이용해 B-Tree 형태로 인덱스를 구축하므로 Rectangle의 "R"과 B-Tree의 "Tree"를 섞어서 R-Tree라는 이름이 붙어졌으며, 공간(Spatial) 인덱스라고도 한다.<br>
일반적으로는 WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용된다. 뿐만 아니라 CAD/CAM 소프트웨어 또는 회로 디자인 등과 같이 좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용할 수 있다.<br>
[그림 5-21]에서 알 수 있다시피, R-Tree는 각 도형(더 정확히는 도형의 MBR)의 포함 관계를 이용해 만들어진 인덱스다.<br>
따라서 Contains() 또는 Intersect() 등과 같은 포함 관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스를 이용할 수 있다.<br>
대표적으로는 "현재 사용자의 위치로부터 반경 5km 이내의 음식점" 등과 같은 검색에 사용할 수 있다.<br>

<img src="/index/img/5-23.png" width="500px;" />

## 5.6 Fractal-Tree 인덱스

Fractal-Tree는 최근에 개발된 기술로 TokuTek(http://tokutek.com)이라는 회사에서 독점적인 특허로 등록된 알고리즘이다.<br>
MySQL의 스토리 엔진인 TokuDB에만 적용되어 있다.<br>

### 5.6.1 Fractal-Tree 의 특성

B-Tree 인덱스에서 인덱스 키를 검색하거나 변경하는 과정 중에 발생하는 가장 큰 문제는 **디스크 랜덤 I/O가 상대적으로 많이 필요하다는 것**이다.<br>
Fractal-Tree는 이러한 B-Tree의 단점을 최소화하고, 이를 순차 I/O로 변환해서 처리할 수 있다는 것이 가장 큰 장점이다.<br>
그래서 Fractal-Tree를 스트리밍(Streaming) B-Tree라고도 한다.<br>
Fractal-Tree는인덱스 키가 추가되거나 삭제될 때 B-Tree 인덱스보다 더 많은 정렬 작업이 필요하며, 이 때문에 더 많은 CPU 처리가 필요할지 모른다.<br>
하지만 인덱스의 단편화가 발생하지 않도록 구성할 수 있고, 인덱스 키값을 클러스터링하기 때문에 B-Tree보다는 대용량 테이블에서 높은 성능을 보장한다.<br>
B-Tree 인덱스는 일정 수준을 넘어서면 급격한 성능 저하가 발생하는데, Fractal-Tree는 이런 급격한 성능 저하 현상은 없다.<br>
오랜시간 동안 데이터가 변경되면서 단편화가 발생하고, 그 때문에 인덱스의 효율이 떨어지는 현상을 에이징(Aging)이라고 한다. 이러한 현상 때문에 테이블이나 인덱스 최적화(옵티마이즈)하는데 Fractal-Tree에서는 이러한 현상이 발생하지 않기 때문에 별도의 최적화 작업이 필요하지 않다.<br>

### 5.6.2 Fractal-Tree의 가용성과 효율성

Fractal-Tree의 또 다른 장점은 B-Tree의 장점을 그대로 Fractal-Tree도 가지고 있다는 것이다.<br>
B-Tree로 생성된 인덱스를 Fractal-Tree로 변경해도 충분히 동일한 효과를 얻을 수 있다.<br>

## 5.7 전문 검색(Full Text search) 인덱스

문서 전체에 대한 분석과 검색을 위한 알고리즘을 전문 검색(Full Text search) 인덱스라고 하는데, 전문 검색 인덱스는 일반화된 기능의 명칭이지 전문 검색 알고리즘의 이름을 지칭하는 것은 아니다.<br>
전문 검색 인덱스에서 문서의 키워드를 인덱싱하는 기법에 따라 크게 구분자(Stopword)와 N-그램으로 나눠서 생각해 볼 수 있다.<br>

### 5.7.1 인덱스 알고리즘

전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축한다.<br>

**구분자(Stopword) 기법**

전문의 내용을 공백이나 탭(띄어쓰기) 또는 마침표와 같은 문장 기호, 그리고 사용자가 정의한 문자열을 구분자로 등록한다.<br>
구분자 기법은 이처럼 등록된 구분자를 이용해 키워드를 분석해 내고, 결과 단어를 인덱스로 생성해 두고 검색에 이용하는 방법을 말한다.<br>
MySQL의 내장 전문 검색(FullText search) 엔진은 구분자 방식만으로 인덱싱할 수 있다.<br>
구분자 기법은 문서의 본문으로부터 키워드를 추출해 내는 작업이 추가로 필요할 뿐, 내부적으로는 B-Tree 인덱스를 그대로 사용한다.<br>
전문 검색 엔진을 통해 조회되는 레코드는 검색어나 본문 내용으로 정렬되어 조회되지 않는다.<br>
전문 검색에서 결과의정렬은 일치율(Match percent)이 높은 순으로 출력되는 것이 일반적이다.<br>

**N-그램(n-Gram) 기법**

N-그램이란 본문을 무조건적으로 몇 글자씩 잘라서 인덱싱하는 방법이다. 구분자에 의한 방법보다는 인덱싱 알고리즘이 복잡하고 만들어진 인덱스의 크기도 상당히 큰 편이다.<br>
N-그램에서 n은 인덱싱할 키워드의 최소 글자(또는 바이트) 수를 의미하는데, 일반적으로는 2글자 단위로 키워드를 쪼개서 인덱싱하는 2-Gram(또는 Bi-Gram 이라고도 한다) 방식을 많이 사용 된다.<br>
2-Gram 인덱싱 기법은 2글자 단위의 최소 키워드에 대한 키를 관리하는 프론트엔드(Front-end) 인덱스와 2글자 이상 키워드 묶음(n-SubSequence Window)을 관리하는 백엔드(Back-end) 인덱스 2개로 구성된다. 인덱스의 생성 과정은 [그림 5-26]과 같이, 2가지 단계로 나눠서 처리된다.<br>

- 첫 번째 단계로, 문서의 본문을 2글자보다 큰 크기로 블록을 구분해서 백엔드 인덱스(3)를 생성
- 두 번째 단계로, 백엔드 인덱스의 키워드들을 2글자씩 잘라서 프론트엔드 인덱스(6)를 생성

<img src="/index/img/5-26.png" width="500px;" />

인덱스의 검색 과정은 입력된 검색어를 2바이트 단위로 동일하게 잘라서 프론트엔드 인덱스를 검색한다.<br>
그 결과를 대상 후보 군으로 선정하고, 백엔드 인덱스를 통해 최종 검증을 거쳐 일치하는 결과를 가져온다.<br>

### 5.7.3 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하려면 반드시 MATCH(...) AGAINST(...) 구문으로 검색 쿼리를 작성해야 하며, MATCH 절의 괄호에 포함되는 내용은 반드시 사용할 전문 검색 인덱스에 정의된 칼럼이 모두 명시되어야 한다.

## 5.8 비트맵 인덱스와 함수 기반 인덱스

MySQL 스토리지 엔진 가운데 비트맵 인덱스와 함수 기반(Function based) 인덱스를 지원하는 스토리지 엔진은 없다.<br>
그렇지만 함수 기반의 인덱스는 쉽게 우회해서 구현할 수 있다.<br>
테이블에 함수의 결과 값을 저장하기 위한 칼럼을 추가하고, 그 칼럼에 인덱스를 생성해서 사용하면 된다.<br>
길이가 상당히 긴 칼럼에 대한 동등 비교 검색을 위해서는 문자열의 해시 값을 생성해서 별도의 칼럼에 저장하고 해당 칼럼에 인덱스를 생성하는 방식을 많이 사용한다.<br>

## 5.9 클러스터링 인덱스

인덱스에서 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것이다.<br>
MySQL에서 클러스터링 인덱스는 InnoDB와 TokuDB 스토리지 엔진에서만 지원한다.<br>

### 5.9.1 클러스터링 인덱스

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉, 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.<br>
여기서 중요한 것은 프라이머리 키값에 의해 레코드의 저장 위치가 결정된다는 것이다.<br>
또한 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미한다.<br>
프라이머리 키값으로 클러스터링된 테이블은 프라이머리 키값 자체에 대한 의존도가 상당히 크기 때문에 신중이 프라이머리 키를 결정해야 한다.<br>
클러스터링 인덱스는 프라이머리 키값에 의해 레코드의 저장 위치가 결정되므로 사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수 있다.<br>
그래서 "클러스터링 인덱스"와 "클러스터 테이블"은 동의어로 사용되기도 한다.<br>
일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느릴 수밖에 없다.<br>

```
B-Tree 인덱스도 인덱스 키값으로 이미 정렬되서 저장된다.
하지만 일반적인 B-Tree 인덱스를 클러스터링 인덱스라고 부르지 않는다.
테이블의 레코드가 프라이머리 키값으로 정렬되어 저장되는 경우만을 "클러스터링 인덱스" 또는 "클러스터링 테이블"이라고 한다.
```

<img src="/index/img/5-31.png" width="500px;" />

[그림 5-31]의 클러스터링 인덱스 구조를 보면 클러스터링 테이블의 구조 자체는 일반 B-Tree와 많이 비슷하게 닮아 있다.<br>
하지만 B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼이 같이 저장돼 있음을 알 수 있다.<br>
즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것이다.<br>
그렇다면, 프라이머리 키가 없는 InnoDB 테이블은 어떻게 클러스터 테이블로 구성되는 건가?<br>
프라이머리 키가 없는 경우에는 InnoDB 스토리 엔진이 다음의 우선순위대로 프라이머리 키를 대체할 컬럼을 선택한다.<br>

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터 키로 선택
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터 키로 선택

클러스터링 인덱스는 (InnoDB 테이블별로) 단 한번만 가질 수 있는 엄청난 혜택이므로 가능하다면 프라이머리 키를 명시하자.<br>

### 5.9.2 보조 인덱스(Secondary index)에 미치는 영향

프라이머리 키가 보조 인덱스(Secondary index)에 어떤 영향을 미치는지 한번 살펴보자.<br>
MyISAM이나 MEMORY 테이블과 같은 클러스터링이 되지 않은 테이블은 INSERT될 때 한번 저장된 공간에서 절대 이동하지 않는다.<br>
데이터 레코드가 저장된 주소는 내부적인 레코드 아이디(ROWID) 역할을 한다고 언급한 바 있다.<br>
프라이머리 키나 보조 인덱스의 각 키는 그 주소(ROWID)를 이용해 실제 데이터를 찾아온다.<br>
그래서 MyISAM 테이블이나 MEMORY 테이블에서는 프라이머리 키와 보조 인덱스는 구조적으로 아무런 차이가 없다.<br>
InnoDB 테이블(클러스터 테이블)의 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키값을 저장하도록 구현돼 있다.<br>

```sql
CREATE TABLE employees (
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY (emp_no),
	INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name = 'Aamer';
```

**MyISAM**

ix_firstname 인덱스를 검색해서 레코드의 주소를 확인<br>
레코드의 주소를 이용해 최종 레코드를 가져옴<br>

**InnoDB**

ix_firstname 인덱스를 검색해 레코드의 프라이머리 키값을 확인<br>
프라이머리 키값을 이용해 다시 한번 테이블을 검색한 후 최종 레코드를 가져옴<br>
InnoDB가 MyISAM보다 조금 더 복잡하게 처리되는것을 알 수 있다.<br>
하지만 InnoDB 테이블에서 프라이머리 키로 레코드를 읽어 오는 과정은 매우 빠르게 처리되므로 성능을 걱정할 필요는 없다.<br>

### 5.9.3 클러스터 인덱스의 장점과 단점

**장점**

- 프라이머리 키(클러스터 키)로 검색할 때 처리 성능이 매우 빠름(특히, 프라이머리 키를 범위 검색하는 경우 매우 빠르다)
- 테이블의 모든 보조 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(이를 커버링 인덱스라고 한다.)

**단점**

- 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다.
- 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 조금 느리다.
- INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느리다.
- 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느리다.

### 5.9.4 클러스터 테이블 사용시 주의사항

**클러스터 인덱스 키의 크기**

클러스터 테이블의 경우, 모든 보조 인덱스가 프라이머리 키(클러스터 키) 값을 포함한다. 그래서 프라이머리 키의 크기가 커지면 보조 인덱스도 자동으로 크기가 커진다.<br>
인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 더 필요해진다는 뜻이므로 InnoDB 테이블의 프라이머리 키는 신중하게 선택해야 한다.<br>

**프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성할 것(가능한 경우)**

InnoDB의 프라이머리 키는 클러스터 키로 사용되며, 이 값에 의해 레코드의 위치가 결정된다.<br>
즉, 프라이머리 키로 검색하는 경우(특히 범위로 많은 레코드를 검색하는 경우) 클러스터되지 않은 테이블에 비해 매우 빠르게 처리될 수 있음을 의미한다.<br>
프라이머리 키는 그 의미만큼이나 중요한 역할을 하기 때문에 대부분 검색에서 상당히 빈번하게 사용되는 것이 일반적이다.<br>
그러므로 설령 그 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 설정하는 것이 좋다.<br>

**AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우**

프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 인조 식별자(Surrogate Key)라고 한다.<br>
로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO-INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다.<br>

## 5.10 유니크 인덱스

인덱스라기 보다 제약 조건에 가깝다고 볼 수 있다.

테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데, MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.

유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정의 값이 아니므로 2개 이상 저장될 수 있다.

### 5.10.1 유니크 인덱스와 일반 보조 인덱스의 비교

유니크 인덱스와 일반 보조 인덱스의 읽기와 쓰기를 성능 관점에서 살펴보자.

**인덱스 읽기**

유니크 하지 않은 보조 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 때문에 느린 것이 아니다.<br>
읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.<br>

**인덱스 쓰기**

유니크 인덱스의 키값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다. 그래서 일반 보조 인덱스의 쓰기보다 느리다.<br>
MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 아주 빈번이 발생한다.<br>
InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 인서트 버퍼(Insert Buffer)가 사용된다. 그래서 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만 안타깝게도 유니크 인덱스는 반드시 중복 체크를 해야하므로 작업 자체를 버퍼링하지 못한다.<br>
이 때문에 유니크 인덱스는 일반 보조 인덱스보다 더 느려진다.<br>

### 5.10.2 유니크 인덱스 사용 시 주의사항

꼭 필요한 경우라면 유니크 인덱스를 생성하는 것은 당연하다. 하지만 더 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지 않는 것이 좋다.<br>
하나의 테이블에서 같은 칼럼의 유니크 인덱스와 일반 인덱스를 생성하지 않는 편이 좋다.<br>
하나의 테이블에서 같은 칼럼에 유니크 인덱스와 일반 인덱스를 각각 중복해서 생성해 둔 경우가 가끔 있는데, MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요는 없다.<br>
즉, 유니크 인덱스도 일반 보조 인덱스와 같은 역할을 동일하게 수행할 수 있으므로 다음과 같이 중복해서 보조 인덱스를 만들어 줄 필요는 없다.<br>

```sql
CREATE TABLE tb_unique (
	id INTEGER NOT NULL,
	nick_name VARCHAR(100),
	PRIMARY KEY (id),
	UNIQUE INDEX ux_nickname (nick_name),
	INDEX ix_ninkname (nick_name)
);
```

결론적으로 유일성이 꼭 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 보조 인덱스를 생성하는 방법도 한 번씩 고려해보자.

## 5.11 외래키

InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.<br>
InnoDB의 외래키 관리에는 중요한 두 가지 특성이 있다.<br>

- 테이블 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경함(잠금 대기)을 발생시키지 않는다.

### 5.11.1 자식 테이블의 변경이 대기하는 경우

자식 테이블의 외래키 칼럼의 변경(INSERT, UPDATE)은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 된다. → **외래키 관리의 첫번째 특징**<br>
만약 자식 테이블의 외래키(pid)가 아닌 칼럼(tb_child 테이블의 fd 칼럼과 같은)의 변경은 외래키로 인한 잠금 확장(바로 위에서 살펴본 예제와 같은)이 발생하지 않는다. → **외래키 관리의 두번째 특징**<br>

### 5.11.2 부모 테이블의 변경 작업이 대기하는 경우

물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조키가 부모 테이블에 있는지 확인한다는 것은 이미 다들 알고 있을 것이다.<br>
하지만 물리적인 외래키 고려 사항은, 이러한 체크 작업이 아니라 이런 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 한다는 것이다.<br>
또한 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미친다.<br>

## 5.12 기타 주의사항

**스토리지 엔진별 지원 인덱스 목록**

인덱스는 MySQL 엔진 레벨이 아니라 스토리지 엔진 레벨에 포함되는 영역이므로 스토리지 엔진의 종류별로 사용 가능한 인덱스의 종류가 다르다.

<img src="/index/img/5-32.png" width="500px;" />

**analyze와 optimize의 필요성**

MyISAM이나 InnoDB 테이블의 경우, 인덱스에 대한 통계 정보를 관리하고 각 통계 정보를 기반으로 쿼리의 실행 계획을 수립한다.

<img src="/index/img/5-33.png" width="500px;" />

보기 쉽게 중요하지 않은 정보는 "..." 으로 줄여서 표기하였다.<br>
여기서 가장 중요한 칼럼은 Cardinality 항목이다.<br>
InnoDB와 MyISAM 모두 거의 컬럼의 Cardinality에 의존해서 실행 계획을 수립한다.<br>
