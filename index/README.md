## 05. 인덱스
> MySQL에서 사용 가능한 인덱스의 종류 및 특성을 알아본다.

## 5.1 디스크 읽기 방식

### 5.1.1 저장 매체

**일반적으로 서버에 사용되는 저장 매체는 아래와 같이 구분된다.**
- 내장 디스크(Internal Disk)
- DAS(Direct Attached Storage)
    - 내장 디스크 용량문제를 해결하기 위해 주로 사용하는 것으로 컴퓨터 본체와 달리 디스크만 있는 것이 특징이다.
    - 하나의 컴퓨터 본체에만 연결해서 사용할 수 있기 때문에 디스크 정보를 여러 컴퓨터가 동시에 공유하는 것이 불가능하다.
- NAS(Network Attached Storage)
- SAN(Storage Area Network)

내장 디스크와 DAS의 문제점을 동시에 해결하기 위해 주로 NAS와 SAN을 사용한다.<br>
DAS와 NAS의 가장 큰 차이는 여러 컴퓨터에서 동시에 사용할 수 있는지와 컴퓨터 본체와 연결되는 방식이다.<br>
NAS는 TCP/IP를 통해 연결된다. NAS는 동시에 여러 컴퓨터에서 공유해서 사용할 수 있는 저장매체이지만 SATA나 SAS 방식의 직접 연결보다는 속도가 매우 느리다.<br>
SAN은 DAS로 구축할 수 없는 대용량의 스토리지 공간을 제공하는 장치이다.<br>
SAN은 여러 컴퓨터에서 동시에 사용할 수 있을뿐더러 컴퓨터 본체와 광케이블로 연결되기 때문에 상당히 빠르고 안정적인 데이터

## 5.2 인덱스란?

칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-Value pair)으로 인덱스를 만들어 두는 것이다.<br>
칼럼의 값을 주어진 순서로 미리 정렬해서 보관하는 것이다.<br>
결론적으로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 대신 데이터의 읽기 속도를 높이는 기능이다.<br>
인덱스를 역할별로 구분하면 프라이머리 키(Primary Key)와 보조 키(Secondary Key)로 구분해 볼 수 있다.<br>

**프라이머리 키(Primary Key)**

그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미<br>
테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 우리는 이를 식별자라고도 부른다.<br>
NULL 값을 허용하지 않으며 중복을 허용하지 않는 것이 특징이다.<br>

**보조 키(Secondary Key)**

프라이머리 키를 제외한 나머지 모든 인덱스는 보조 인덱스(Secondary Index)로 분류한다.<br>
데이터 저장 방식(알고리즘)별로 구분하자면 많은 분류로 가능하겠지만, 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다. 최근에는 새롭게 Fractal-Tree 인덱스와 같은 알고리즘도 추가되었다.<br>

- B-Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘이다.
매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 전방(Prefix) 일치와 같이 값의 일부만 검색하고자 할 때는 사용할 수 없다.
- Fractal-Tree 알고리즘은 B-Tree 알고리즘의 단점을 보완하기 위해 고안된 알고리즘이다.
데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게 설계된 것이 특징이다.

### 5.3 B-Tree 인덱스 (Balanced Tree)

B-Tree는 칼럼의 원래 값을 변형시키지 않고 (값의 앞부분만 잘라서 관리하기는 함) 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다. 처리(읽고 쓰기)를 보장해준다. 하지만 그만큼 고가의 비용이 발생한다.

### 5.3.1 구조 및 특성

데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리하는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.<br>
그림 5-6은 B-Tree 인덱스의 각 노드와 데이터 파일의 관계를 표현한 것이다.<br>

<img src="/index/img/5-6.png" width="500px;" />

InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장된다.<br>
InnoDB에서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이블이 생성된다.<br>
클러스터링이란 비슷한 값들을 최대한 모아서 저장하는 방식을 의미한다.

### 5.3.2 B-Tree 인덱스 키 추가 및 삭제

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.<br>

**인덱스 키 추가**

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.<br>
저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.<br>
만약 리프 노드가 꽉차서 더는 저장할 수 없을 때는 리프 노드가 분리(Split)돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.<br>
이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.<br>
MyISAM이나 Memory 스토리지 엔진을 사용하는 테이블에서 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 반영한다.<br>
즉, B-Tree에 키를 추가하는 작업이 완료될 때까지 클라이언트는 쿼리의 결과를 받지 못하고 기다리게 된다.<br>
InnoDB 스토리지 엔진은 [그림 5-8] 과 같이 상황에 따라 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지, 아니면 바로 처리할지 결정하게 된다.<br>

<img src="/index/img/5-8.png" width="500px;" />

1. 사용자의 쿼리 실행
2. InnoDB의 버퍼 풀에 새로운 키 값을 추가해야 할 페이지(B-Tree의 리프 노드)가 존재한다면 즉시 키 추가 작업 처리
3. 버퍼 풀에 B-Tree의 리프 노드가 없다면 인서트 버퍼에 추가할 키값과 레코드의 주소를 임시로 기록해 두고 작업 완료(사용자의 쿼리는 실행 완료됨)
4. 백그라운드 작업으로 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키값이 있는지 확인한 후, 있다면 병합함(B-Tree에 인덱스 키와 주소를 저장)
5. 데이터베이스 서버 자원의 여유가 생기면 MySQL 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키와 주소 값을 머지(B-Tree에 인덱스 키와 주소를 저장) 시킴

**인덱스 키 삭제**

삭제는 간단하다. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.<br>
이렇게 삭제된 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 또는 재활용할 수 있다.<br>
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O가 필요한 작업이다.<br>
MyISAM이나 Memory 스토리지 엔진의 테이블에서는 인서트 버퍼와 같은 기능이 없으므로 인덱스 키 삭제가 완료된 후 쿼리 실행이 완료된다.<br>

**인덱스 키 변경**

B-Tree의 키값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리 된다.

**인덱스 키 검색**

INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서다.<br>
인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 "트리 탐색(Tree traversal)"이라고 한다.<br>
부등호("<>") 비교나 값의 뒷부분이 일치하는 경우에는 B-Tree 인덱스를 이용한 검색이 불가능하다. 또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다는 것이다.<br>
함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의해야 한다.<br>
InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락(갭 락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.<br>
따라서 UPDATE 나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.<br>

### 5.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본단위를 페이지(Page) 또는 블록(Block)이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.<br>
페이지는 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다. 인덱스도 결국은 페이지 단위로 관리되며, 위의 B-Tree 그림에서 루트와 브랜치, 그리고 리프(Leaf) 노드를 구분한 기준이 바로 페이지 단위이다.<br>
DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. MySQL의 B-Tree는 자식 노드는 인덱스의 페이지 크기와 키 값에 크기에 따라 결정된다.<br>
인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.<br>
인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스 크기가 커진다는 것을 의미한다.<br>
인덱스를 캐시해 두는 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 커질수록 메모리(버퍼 풀이나 캐시)에 캐시해 둘 수 있는 레코드 수는 줄어들 것을 의미한다. 자연히 메모리의 효율이 떨어지게 되는 결과를 가져온다.<br>

**B-Tree 깊이**

B-Tree 인덱스의 깊이(Depth)는 상당히 중요하지만 직접적으로 제어할 방법이 없다.<br>
인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 작아지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이(Depth)가 깊어져서 **디스크 읽기가 더 많이 필요하게 된다.**<br>
위 내용은 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋다는 것을 강조하기 위함이고, 실제로는 아무리 대용량의 데이터베이스라도 B-Tree의 깊이(Depth)가 4~5 이상까지 깊어지는 경우는 거의 발생하지 않는다.<br>

**선택도(기수성)**

인덱스에서 선택도(Selectivy) 또는 기수성(Cardinality)는 거의 같은 의미로 사용되며, **모든 인덱스 키값 가운데 유니크한 값의 수를 의미**한다.<br>
인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

**읽어야 하는 레코드의 건수**

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.<br>
테이블에 레코드가 100만 건이 저장돼 있는데, 그 중에서 50만 건을 읽어야 하는 쿼리가 있다고 가정해보자.<br>
이 작업은 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지, 인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단해야 한다.<br>
인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있는데, 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 많이 드는 작업인 것으로 예측한다.<br>
즉, 인덱스를 통해 읽어야할 레코드의 건수(물론 옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.<br>

### 5.3.4 B-Tree 인덱스를 통한 데이터 읽기

MySQL이 인덱스를 이용하는 대표적인 방법 3가지를 소개한다.

**인덱스 레인지 스캔**

<img src="/index/img/5-9.png" width="500px;" />

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.<br>
[그림 5-9]에서 알 수 있듯이 루트 노드에서 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 실제로 원하는 시작 지점을 찾을 수 있다.<br>
일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.<br>
B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많은데, 이 과정을 좀 더 자세히 보자.<br>

<img src="/index/img/5-10.png" width="500px;" />

그림에서 중요한 것은 [그림 5-10]에서 중요한 것은 인덱스의 리프 노드에서 검색 조건에 일치하는 건들을 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.<br>
이 때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한번씩 실행된다.<br>
인덱스를 통해 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류되는 것이다.<br>

**인덱스 풀 스캔**

인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스킨이라고 한다.<br>
대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.<br>

<img src="/index/img/5-11.png" width="500px;" />

먼저 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 인덱스의 리프 노드를 연결하는 링크드 리스트(Linked list, 리프 노드를 연결하는 세로로 그려진 두쌍씩의 화살표)를 따라서 처음부터 끝까지 스캔하는 방식을 인덱스 풀 스캔이라고 한다. 인덱스 레인지보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.

**루스 인덱스 스캔**

느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.

<img src="/index/img/5-12.png" width="500px;" />

루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간마다 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.<br>
일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다.<br>

### 5.3.5 다중 컬럼(Multi-column) 인덱스

두 개 이상의 컬럼으로 구성된 인엑스를 다중 칼럼 인덱스라고 하며, 또한 2개 이상의 컬럼이 연결됐다고해서 "Concatenated Index"라고도 한다.

<img src="/index/img/5-13.png" width="500px;" />

인덱스 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다. 즉, 두 번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 레코드에만 의미가 있다는 것이다.<br>
만약 칼럼이 4개인 인덱스를 생성한다면 세 번째 칼럼은 두 번째 칼럼에 의존해서 정렬되고 네 번째 칼럼은 다시 세번째 칼럼에 의존해서 정렬 된다.<br>
다중 컬럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며 또한 아주 신중히 결정해야 하는 이유가 바로 여기에 있다.<br>

### 5.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정된다.

**인덱스의 정렬**

인덱스를 구성하는 칼럼 가운데 오름차순(ASC)과 내림차순(DESC)를 혼합해서 만들어야 할 때가 있다.<br>
MySQL에서는 칼럼의 값을 역으로 변환해서 구현하는 것이 유일한 방법이다.<br>

**인덱스 스캔 방향**

<img src="/index/img/5-14.png" width="500px;" />

인덱스를 역순으로 정렬되게 할 수 없지만 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.<br>
인덱스를 오름차순으로 읽으면 최종적으로 출력되는 결과 레코드는 자동으로 오름차순으로 정렬된 결과이며, 내림차순으로 읽으면 그 결과는 내림차순으로 정렬된 상태가 되는 것이다.<br>
쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 최적화가 필요한 경우, MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.<br>

### 5.3.7 B-Tree 인덱스의 가용성과 효율성

쿼리의 WHERE 조건이나 GROUP BY 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.<br>
여기서는 어떤 조건에서 인덱스를 사용할 수 있고 어떨 때 사용할 수 없는지 살펴 본다.<br>

**비교 조건의 종류와 효율성**

다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교("=") 인지 아니면 크다(">") 또는 작다("<")와 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.<br>
공식적인 명칭은 아니지만 작업의 범위를 결정하는 조건을 "작업 범위 결정 조건"이라 하고, 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 "필터링 조건" 또는 "체크 조건"이라고 표현한다.<br>
작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 (최종적으로 가져오는 레코드는 작게 만들지 몰라도) 쿼리의 처리 성능을 높이지 못한다. 오히러 쿼리 실행을 더 느리게 만들 때가 많다.<br>

**인덱스의 가용성**

B-Tree 인덱스의 특징은 왼쪽 값에 기준(Left-most)해서 오른쪽 값이 정렬돼 있다는 것이다. 여기서 왼쪽이라 함은 하나의 칼럼 내에서뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 적용된다.

<img src="/index/img/5-16.png" width="500px;" />

```sql
SELECT * FROM employees WHERE first_name LIKE '%mer';
```

이 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없다. 이유는 first_name 칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상수값("%mer")에는 왼쪽 부분이 고정되지 않았기 때문이다.

```sql
SELECT * FROM dept_emp WHERE emp_no >= 10144;
```

위 쿼리는 인덱스가 (dept_no, emp_no) 칼럼 순서대로 생성돼 있다면 인덱스의 선행 칼럼인 dept_no 값 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.

케이스 B의 인덱스는 다중 칼럼으로 인덱스가 만들어졌기 때문에 dept_no에 대해 먼저 정렬한 후, 다시 emp_no 칼럼값으로 정렬돼 있기 때문이다.

**가용성과 효율성 판단**

기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다. 여기서 사용할 수 없다는 것은 작업 범위 결정 조건으로 사용할 수 없다는 것을 의미하며, 경우에 따라서는 체크 조건으로 인덱스를 사용할 수 있다.

- NOT-EQUAL 로 비교된 경우 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")

    ```sql
    ... WHERE column <> 'N'
    ... WHERE column NOT IN (10, 11, 12)
    ... WHERE column IS NOT NULL
    ```

- LIKE '%??' (앞부분이 아닌 뒷부분이 불일치) 형태로 문자열 패턴이 비교된 경우

    ```sql
    ... WHERE column LIKE '%승환'
    ... WHERE column LIKE '_승환'
    ... WHERE column LIKE '%승%'
    ```

- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우

    ```sql
    ... WHERE SUBSTRING(column, 1, 1) = 'X'
    ... WHERE DAYOFMONTH(column) = 1
    ```

- 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변형해야 비교가 가능한 경우)

    ```sql
    ... WHERE char_column = 10
    ```

- 문자열 데이터 타입의 콜레이션이 다른 경우

    ```sql
    ... WHERE utf8_bin_char_column = eukr_bin_char_column
    ```

MySQL에서는 NULL 값도 인덱스로 관리된다. 다음과 같은 WHERE 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.

```sql
... WHERE column IS NULL ..
```

다중 칼럼으로 만들어진 어떤 조건에서 사용될 수 있고, 어떤 경우에는 절대 사용될 수 없는지 살펴보자. 다음과 같은 인덱스가 있다고 가정해보자.

Index ix_text (column_1, column_2, column_3, ... , column_n)

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
  - column_1 칼럼에 대한 조건이 없는 경우
  - column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우( i 는 2보다 크고 n보다 작은 임의의 값을 의미)
  - column_1 ~ column_(i-1) 칼럼까지 Equal 형태("=" 또는 "IN")로 비교
  - column_i 칼럼에 대한 다음 연산자 중 하나로 비교

      ```sql
      Equal("=" 또는 "IN")
      크다 작다 형태(">" 또는 "<")
      LIKE 로 좌측 일치 패턴(LIKE "승환%")
      ```

인덱스를 사용하는 경우와 그렇지 않은 상황에 해당하는 쿼리의 조건 몇가지를 예제로 살펴보자.

```sql
// 다음 쿼리는 인덱스를 사용할 수 없다.
... WHERE column_1 <> 2

// 다음 쿼리는 column_1과 column_2까지 범위 결정 조건으로 사용됨
... WHERE column_1 = 1 AND column_2 > 10

// 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로 사용됨
... WHERE column_1 IN (1,2) AND column_2 = 2 AND column_3 <= 10

// 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로, column_4 는 체크 조건으로 사용됨
... WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10, 20, 30) AND column_4 <> 100

// 다음 쿼리는 column_1, column_2, column_3, column_4 까지 범위 결정 조건으로 사용됨
// 좌측 패턴 일치 LIKE 비교는 크다 또는 작다 비교와 동급으로 생각하면 될 듯하다.
... WHERE column_1 = 1 AND column_2 IN (2,4) AND column_3 = 30 AND column_4 LIKE '김승%'

// 다음 쿼리는 column_1, column_2, column_3, column_4, column_5 모두 범위 결정 조건으로 사용됨
... WHERE column_1 = 1 AND column_2 = 2 AND column_3 = 30 AND column_4 = '김승환' AND column_5 = '서울'
```

여기까지의 내용은 모두 B-Tree 인덱스의 특징이므로 MySQL뿐 아니라 대부분의 RDBMS에도 동일하게 적용된다.

## 5.4 해시(Hash) 인덱스

해시 인덱스는 동등 비교 검색에는 최적화돼 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다.

### 5.4.1 구조 및 특성

<img src="/index/img/5-17.png" width="500px;" />

장점은 실제 키값과는 관계 없이 인덱스 크기가 작고 검색이 빠르다는 것이다.<br>
[그림 5-17] 을 보면 알다시피 트리 형태의 구조가 아니므로 검색하고자 하는 값을 주면 해시 함수를 거쳐서 찾고자 하는 키값이 포함된 버켓을 알아낼 수 있다.<br>
그리고 그 버켓 하나만 읽어서 비교해보면 실제 레코드가 저장된 위치를 바로 알 수 있다. 그래서 트리 내에서 여러 노드를 읽어야 하지만 레코드의 주소를 알아 낼 수 있는 B-Tree보다 상당히 빨리 결과를 가져올 수 있다.<br>

```
B-Tree 인덱스나 해시 인덱스 모두 각 키값과 레코드 주소값 등의 정보를 저장해 두는 공간이 필요하다.
이 저장 공간은 작업의 기본 단위가 고정된 크기로 할당된다. B-Tree에서는 이처럼 고정된 크기의 저장 공간을 노드라고 하며, 해시 인덱스에서는 이를 버켓이라고 한다.
버켓은 크게 중요한 개념은 아니므로 키 값이 저장된 단위 크기의 메모리 공간으로 이해하면 된다.
```

해시 인덱스는 원래의 키값을 저장하는 것이 아니라 함수의 결과(일반적으로는 단순 숫자값)만 저장하므로 키 칼럼의 값이 아무리 길어도 실제 해시 인덱스에 저장되는 값은 4~8바이트 수준으로 상당히 줄어든다. 그래서 해시 인덱스는 B-Tree 인덱스보다는 상당히 작은 편이다.

```
해시 알고리즘은 DBMS에서는 대표적으로 검색을 위한 인덱스와 테이블의 파티셔닝 용도로 사용된다.
검색을 위해 해시 알고리즘이 사용되는 경우에는 해시 함수의 결과 값이 범위가 넓어야 충돌이 줄어들고 그만큼 검색 성능이 높아진다.
하지만 테이블의 파티셔닝 용도로 사용되는 경우에는 해시 함수가 필요한 파티션의 개수만큼만 만들어내도록 설계해야 하므로 해시 함수의 결과 값의 범위를 좁게 사용한다.
MySQL의 해시 파티션은 이러한 해시 알고리즘을 이용해 테이블을 파티셔닝하는 기능이다.
```

### 5.4.2 해시 인덱스의 가용성 및 효율성

해시 인덱스는 빠른 검색을 제공하지만 키값 자체가 변환되어 저장되기 때문에 범위를 검색하거나 원본값 기준으로 정렬할 수 없다.<br>
해시 인덱스의 효율성을 살펴본다.<br>

**작업 범위 제한 조건으로 해시 인덱스를 사용하는 쿼리**

다음 패턴의 쿼리는 동등 비교 조건으로 값을 검색하고 있으므로 해시 인덱스의 빠른 장점을 그대로 이용할 수 있다.<br>
IN 연산자도 여러 개의 동등 비교로 풀어서 처리할 수 있기 때문에 같은 효과를 얻을 수 있다.<br>

```sql
SELECT ... FROM tb_hash WHERE column = '검색어';
SELECT ... FROM tb_hash WHERE column <=> '검색어';
SELECT ... FROM tb_hash WHERE column IN ('검색어1', '검색어2');
SELECT ... FROM tb_hash WHERE column IS NULL;
SELECT ... FROM tb_hash WHERE column IS NOT NULL;
```

"<=>" 는 "NULL-Safe Equal" 연산자라고 하는데, 비교 양쪽의 값이 NULL이 있을 때를 제외하고는 "=" 연산자와 똑같다.<br>

**해시 인덱스를 전혀 사용하지 못하는 쿼리**

아래와 같은 형태의 크다 또는 작다 기반의 검색은 어떠한 방법으로도 해시 인덱스를 사용할 수 없다.<br>
즉, 작업 범위 결정 조건뿐 아니라 체크 조건의 용도로도 전혀 사용할 수 없다. 대체로 범위 비교나 부정형 비교는 해시 인덱스를 사용할 수 없다.<br>

```sql
SELECT ... FROM tb_hash WHERE column >= '검색어';
SELECT ... FROM tb_hash WHERE column BETWEEN 100 AND 120;
SELECT ... FROM tb_hash WHERE column LIKE '검색어%';
SELECT ... FROM tb_hash WHERE column <> '검색어';
```

해시 인덱스를 사용할 때 주의할 점이 있다. 다중 컬럼으로 생성된 해시 인덱스에서도 모든 칼럼이 동등 조건으로 비교되는 경우에만 인덱스를 사용할 수 있다는 점이다.
